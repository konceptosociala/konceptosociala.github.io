<!DOCTYPE html>
<html lang="en" style="
    --socio-text-color: #F5F5F5;
    --socio-link-color: #FFF;
    --socio-code-color: #FFF;
    --socio-code-bg: #1D1E23;
">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">

    <meta name="description" content="The Flatbox crate contains a quite useful Material trait that allows the developer to create their own materials based on GLSL shaders. Its approximate implementation for the custom material MyMaterial initially looked like this:
&#x2F;&#x2F; Typetag is used to seri…"/>

    <meta property="og:url" content="https:&#x2F;&#x2F;konceptosociala.eu.org&#x2F;blog&#x2F;material-proc-macro&#x2F;" />
    <meta property="og:title" content="Material derive macro for Flatbox | Koncepto Sociala
" />
    <meta property="og:type" content="website" />
    <meta property="og:description" content="The Flatbox crate contains a quite useful Material trait that allows the developer to create their own materials based on GLSL shaders. Its approximate implementation for the custom material MyMaterial initially looked like this:
&#x2F;&#x2F; Typetag is used to seri…" />
    <meta property="og:image" content="
    
        https://konceptosociala.eu.org/img/ks.svg
    
" />

    <meta property="twitter:domain" content="konceptosociala.eu.org">
    <meta property="twitter:url" content="https:&#x2F;&#x2F;konceptosociala.eu.org&#x2F;blog&#x2F;material-proc-macro&#x2F;">
    <meta name="twitter:title" content="Material derive macro for Flatbox | Koncepto Sociala
">
    <meta name="twitter:description" content="The Flatbox crate contains a quite useful Material trait that allows the developer to create their own materials based on GLSL shaders. Its approximate implementation for the custom material MyMaterial initially looked like this:
&#x2F;&#x2F; Typetag is used to seri…">
    <meta name="twitter:image" content="
    
        https://konceptosociala.eu.org/img/ks.svg
    
">

    
    
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/lipis/flag-icons@6.6.6/css/flag-icons.min.css"/>
    
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css" rel="stylesheet" integrity="sha384-9ndCyUaIbzAi2FUVXJi0CjmCapSmO7SnpJef0486qhLnuZ2cdeRhO02iuK6FUUVM" crossorigin="anonymous">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/fork-awesome@1.2.0/css/fork-awesome.min.css" integrity="sha256-XoaMnoYC5TH6/+ihMEnospgm0J1PM/nioxbOUdnM8HY=" crossorigin="anonymous">
    <link href="
    
        https://konceptosociala.eu.org/navbar.css
    
" rel="stylesheet" type="text/css">
    <link href="
    
        https://konceptosociala.eu.org/theme.css
    
" rel="stylesheet" type="text/css">
    <link rel="shortcut icon" href="
    
        https://konceptosociala.eu.org/img/ks.svg
    
" type="image/x-icon">
    
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/4.1.1/animate.min.css"/>
    
    <title>Material derive macro for Flatbox | Koncepto Sociala
</title>
</head>
<body>
    <header>
        <nav class="navbar navbar-expand-lg navbar-dark" style="background: #0F0F11;">
            <div class="container-fluid">
                <a class="navbar-brand" href="
    
        
            https://konceptosociala.eu.org
        
    
">
                    
                        <img src="
    
        https://konceptosociala.eu.org/img/ks.svg
    
" alt="Website logo" height="35">
                    
                </a>
                <a class="navicon-button plus d-lg-none" data-bs-toggle="collapse" data-bs-target="#navbarSupportedContent" aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
                    <div class="navicon"></div>
                </a>
                <div class="collapse navbar-collapse" id="navbarSupportedContent">
                    <ul class="navbar-nav me-auto mb-2 mb-lg-0">
                        
                            
                                <li class="nav-item">
                                    <a class="nav-link" aria-current="page" href="
    
        
            https://konceptosociala.eu.org
        
    
">Home</a>
                                </li>
                            
                        
                            
                                <li class="nav-item">
                                    <a class="nav-link" aria-current="page" href="
    
        
            https://konceptosociala.eu.org/blog
        
    
">Blog</a>
                                </li>
                            
                        
                            
                                <li class="nav-item dropdown">
                                    <a class="nav-link dropdown-toggle" href="#" role="button" data-bs-toggle="dropdown" aria-expanded="false">
                                        Games
                                    </a>
                                    <ul class="dropdown-menu">
                                        
                                            <li><a class="dropdown-item" href="
    
        
            https://konceptosociala.eu.org/games/komunterio
        
    
">Komunterio</a></li>
                                        
                                    </ul>
                                </li>
                            
                        
                            
                                <li class="nav-item dropdown">
                                    <a class="nav-link dropdown-toggle" href="#" role="button" data-bs-toggle="dropdown" aria-expanded="false">
                                        Software
                                    </a>
                                    <ul class="dropdown-menu">
                                        
                                            <li><a class="dropdown-item" href="
    
        
            https://konceptosociala.eu.org/software/flatbox
        
    
">Flatbox</a></li>
                                        
                                            <li><a class="dropdown-item" href="
    
        
            https://konceptosociala.eu.org/software/flatbox-doryen
        
    
">Flatbox Doryen</a></li>
                                        
                                    </ul>
                                </li>
                            
                        
                            
                                <li class="nav-item">
                                    <a class="nav-link" aria-current="page" href="
    
        
            https://konceptosociala.eu.org/music
        
    
">Music</a>
                                </li>
                            
                        
                            
                                <li class="nav-item">
                                    <a class="nav-link" aria-current="page" href="
    
        https://github.com/konceptosociala
    
">GitHub</a>
                                </li>
                            
                        
                            
                                <li class="nav-item">
                                    <a class="nav-link" aria-current="page" href="
    
        
            https://konceptosociala.eu.org/about
        
    
">About</a>
                                </li>
                            
                        
                        
                        <li class="nav-item dropdown">
                            <a class="nav-link dropdown-toggle fa fa-globe mt-1" href="#" role="button" data-bs-toggle="dropdown" aria-expanded="false">
                                <span class="d-lg-none text-uppercase"> en</span>
                            </a>
                            <ul class="dropdown-menu">
                                
                                
                                                                                 
                                        
                                    
                                    <li><a class="dropdown-item" href="https:&#x2F;&#x2F;konceptosociala.eu.org&#x2F;blog&#x2F;material-proc-macro">
                                        
                                            <span class="fi fi-us"></span>
                                        
                                        English
                                    </a></li>
                                
                                    
                                        
                                    
                                    <li><a class="dropdown-item" href="https:&#x2F;&#x2F;konceptosociala.eu.org&#x2F;ua&#x2F;blog&#x2F;material-proc-macro">
                                        
                                            <span class="fi fi-ua"></span>
                                        
                                        Українська
                                    </a></li>
                                
                            </ul>
                        </li>
                        
                    </ul>
                </div>
            </div>
        </nav>
        <div class="curve-header">
            <svg data-name="Layer 1" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 1200 120" preserveAspectRatio="none">
                <path d="M0,0V46.29c47.79,22.2,103.59,32.17,158,28,70.36-5.37,136.33-33.31,206.8-37.5C438.64,32.43,512.34,53.67,583,72.05c69.27,18,138.3,24.88,209.4,13.08,36.15-6,69.85-17.84,104.45-29.34C989.49,25,1113-14.29,1200,52.47V0Z" opacity=".25" class="shape-fill" style="fill: #0F0F11"></path>
                <path d="M0,0V15.81C13,36.92,27.64,56.86,47.69,72.05,99.41,111.27,165,111,224.58,91.58c31.15-10.15,60.09-26.07,89.67-39.8,40.92-19,84.73-46,130.83-49.67,36.26-2.85,70.9,9.42,98.6,31.56,31.77,25.39,62.32,62,103.63,73,40.44,10.79,81.35-6.69,119.13-24.28s75.16-39,116.92-43.05c59.73-5.85,113.28,22.88,168.9,38.84,30.2,8.66,59,6.17,87.09-7.5,22.43-10.89,48-26.93,60.65-49.24V0Z" opacity=".5" class="shape-fill" style="fill: #0F0F11"></path>
                <path d="M0,0V5.63C149.93,59,314.09,71.32,475.83,42.57c43-7.64,84.23-20.12,127.61-26.46,59-8.63,112.48,12.24,165.56,35.4C827.93,77.22,886,95.24,951.2,90c86.53-7,172.46-45.71,248.8-84.81V0Z" class="shape-fill" style="fill: #0F0F11"></path>
            </svg>
        </div>
    </header>

    
<section class="section" style="background: #393C44;">
    <div class="container content" style="min-height: 90vh;">
        
        
<div class="post px-lg-5 mx-lg-5 mt-3">
    <p class="date">~~ 2023-07-22 ~~</p>
    <h1 class="title">Material derive macro for Flatbox</h1>
    <hr class="big-hr">
    <p>The Flatbox crate contains a quite useful <code>Material</code> trait that allows the developer to create their own materials based on GLSL shaders. Its approximate implementation for the custom material <code>MyMaterial</code> initially looked like this:</p>
<pre data-lang="rust" style="background-color:#2b303b;color:#c0c5ce;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#65737e;">// Typetag is used to serialize the collection of materials `Vec&lt;Arc&lt;dyn Material&gt;&gt;`
</span><span>#[</span><span style="color:#bf616a;">typetag</span><span>::</span><span style="color:#bf616a;">serde</span><span>]
</span><span style="color:#b48ead;">impl </span><span>Material </span><span style="color:#b48ead;">for </span><span>MyMaterial {
</span><span>    </span><span style="color:#b48ead;">fn </span><span style="color:#8fa1b3;">pipeline</span><span>(</span><span style="color:#bf616a;">renderer</span><span>: &amp;Renderer) -&gt; Pipeline {      
</span><span>        </span><span style="color:#65737e;">// Shader input attributes
</span><span>        </span><span style="color:#b48ead;">let</span><span> instance_attributes = vec![
</span><span>            ShaderInputAttribute{
</span><span>                binding: </span><span style="color:#d08770;">1</span><span>,
</span><span>                location: </span><span style="color:#d08770;">3</span><span>,
</span><span>                offset: </span><span style="color:#d08770;">0</span><span>,
</span><span>                format: ShaderInputFormat::</span><span style="color:#d08770;">R32G32B32_SFLOAT</span><span>,
</span><span>            },
</span><span>            ShaderInputAttribute{
</span><span>                binding: </span><span style="color:#d08770;">1</span><span>,
</span><span>                location: </span><span style="color:#d08770;">4</span><span>,
</span><span>                offset: </span><span style="color:#d08770;">12</span><span>,
</span><span>                format: ShaderInputFormat::</span><span style="color:#d08770;">R8G8B8A8_UINT</span><span>,
</span><span>            },
</span><span>            ...
</span><span>        ];
</span><span>        
</span><span>        </span><span style="color:#65737e;">// Vertex shader creation
</span><span>        </span><span style="color:#b48ead;">let</span><span> vertex_shader = vk::ShaderModuleCreateInfo::builder()
</span><span>            .</span><span style="color:#96b5b4;">code</span><span>(vk_shader_macros::include_glsl!(
</span><span>                &quot;</span><span style="color:#a3be8c;">./src/shaders/vertex_combined.glsl</span><span>&quot;, 
</span><span>                kind: vert,
</span><span>            ));
</span><span>        
</span><span>        </span><span style="color:#65737e;">// Fragment shader creation
</span><span>        </span><span style="color:#b48ead;">let</span><span> fragment_shader = vk::ShaderModuleCreateInfo::builder()
</span><span>            .</span><span style="color:#96b5b4;">code</span><span>(vk_shader_macros::include_glsl!(
</span><span>                &quot;</span><span style="color:#a3be8c;">./src/shaders/fragment_combined.glsl</span><span>&quot;,
</span><span>                kind: frag,
</span><span>            ));
</span><span>        
</span><span>        </span><span style="color:#65737e;">// Manual graphics pipeline initialization
</span><span>        Pipeline::init(
</span><span>            &amp;renderer,
</span><span>            &amp;vertex_shader,
</span><span>            &amp;fragment_shader,
</span><span>            instance_attributes,
</span><span>            </span><span style="color:#d08770;">40</span><span>,
</span><span>            ShaderTopology::</span><span style="color:#d08770;">TRIANGLE_LIST</span><span>,
</span><span>        ).</span><span style="color:#96b5b4;">expect</span><span>(&quot;</span><span style="color:#a3be8c;">Cannot create pipeline</span><span>&quot;)
</span><span>    }
</span><span>}
</span></code></pre>
<p>That is, the developer had to manually create shaders and graphic pipelines for each material, which would be quite inefficient, as it would be necessary to write a large amount of boilerplate and relatively low-level code. Thus, it is appropriate to split <code>Material</code> trait into several methods:</p>
<pre data-lang="rust" style="background-color:#2b303b;color:#c0c5ce;" class="language-rust "><code class="language-rust" data-lang="rust"><span>#[</span><span style="color:#bf616a;">typetag</span><span>::</span><span style="color:#bf616a;">serde</span><span>(tag = &quot;</span><span style="color:#a3be8c;">material</span><span>&quot;)]
</span><span style="color:#b48ead;">pub trait </span><span>Material: AsAny + std::fmt::Debug + Send + Sync {
</span><span>    </span><span style="color:#b48ead;">fn </span><span style="color:#8fa1b3;">vertex</span><span>() -&gt; &amp;</span><span style="color:#b48ead;">&#39;static </span><span>[</span><span style="color:#b48ead;">u32</span><span>]
</span><span>    </span><span style="color:#b48ead;">where 
</span><span>        </span><span style="color:#b48ead;">Self</span><span>: Sized;
</span><span>
</span><span>    </span><span style="color:#b48ead;">fn </span><span style="color:#8fa1b3;">fragment</span><span>() -&gt; &amp;</span><span style="color:#b48ead;">&#39;static </span><span>[</span><span style="color:#b48ead;">u32</span><span>]
</span><span>    </span><span style="color:#b48ead;">where 
</span><span>        </span><span style="color:#b48ead;">Self</span><span>: Sized;
</span><span>
</span><span>    </span><span style="color:#b48ead;">fn </span><span style="color:#8fa1b3;">input</span><span>() -&gt; ShaderInput
</span><span>    </span><span style="color:#b48ead;">where 
</span><span>        </span><span style="color:#b48ead;">Self</span><span>: Sized;
</span><span>}
</span></code></pre>
<p>, where <code>ShaderInput</code> will be a data structure that will hold the necessary attributes to create a graphics pipeline:</p>
<pre data-lang="rust" style="background-color:#2b303b;color:#c0c5ce;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#b48ead;">pub struct </span><span>ShaderInput {
</span><span>    </span><span style="color:#b48ead;">pub </span><span style="color:#bf616a;">attributes</span><span>: Vec&lt;ShaderInputAttribute&gt;,
</span><span>    </span><span style="color:#b48ead;">pub </span><span style="color:#bf616a;">instance_size</span><span>: </span><span style="color:#b48ead;">usize</span><span>,
</span><span>    </span><span style="color:#b48ead;">pub </span><span style="color:#bf616a;">topology</span><span>: ShaderTopology,
</span><span>}
</span></code></pre>
<p>Let's move everything else to the method of binding the custom material to the renderer:</p>
<pre data-lang="rust" style="background-color:#2b303b;color:#c0c5ce;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#b48ead;">pub fn </span><span style="color:#8fa1b3;">bind_material</span><span>&lt;M: Material + Sync + Send&gt;(&amp;</span><span style="color:#b48ead;">mut </span><span style="color:#bf616a;">self</span><span>){
</span><span>    </span><span style="color:#65737e;">// Checking if the material is already attached
</span><span>    </span><span style="color:#b48ead;">if </span><span style="color:#bf616a;">self</span><span>.material_pipelines.</span><span style="color:#96b5b4;">contains_key</span><span>(&amp;TypeId::of::&lt;M&gt;()) {
</span><span>        log::error!(&quot;</span><span style="color:#a3be8c;">Material type &#39;{}&#39; is already bound!</span><span>&quot;, std::any::type_name::&lt;M&gt;());
</span><span>    } </span><span style="color:#b48ead;">else </span><span>{        
</span><span>        </span><span style="color:#65737e;">// Creating shaders, etc.    
</span><span>        </span><span style="color:#b48ead;">let</span><span> vertex_shader = vk::ShaderModuleCreateInfo::builder().</span><span style="color:#96b5b4;">code</span><span>(M::vertex());
</span><span>        </span><span style="color:#b48ead;">let</span><span> fragment_shader = vk::ShaderModuleCreateInfo::builder().</span><span style="color:#96b5b4;">code</span><span>(M::fragment());
</span><span>        </span><span style="color:#b48ead;">let</span><span> shader_input = M::input();
</span><span>        
</span><span>        </span><span style="color:#65737e;">// Creating a pipeline
</span><span>        </span><span style="color:#b48ead;">let</span><span> pipeline = Pipeline::init(
</span><span>            &amp;</span><span style="color:#bf616a;">self</span><span>,
</span><span>            &amp;vertex_shader,
</span><span>            &amp;fragment_shader,
</span><span>            &amp;shader_input.attributes,
</span><span>            shader_input.instance_size,
</span><span>            shader_input.topology
</span><span>        ).</span><span style="color:#96b5b4;">expect</span><span>(&quot;</span><span style="color:#a3be8c;">Cannot create pipeline</span><span>&quot;);
</span><span>
</span><span>        </span><span style="color:#bf616a;">self</span><span>.material_pipelines.</span><span style="color:#96b5b4;">insert</span><span>(TypeId::of::&lt;M&gt;(), pipeline);
</span><span>    }
</span><span>}
</span></code></pre>
<p>Currently, the implementation of custom materials has become easier, but several problems still remain unsolved:</p>
<ol>
<li>The need to describe each material field (<code>roughness: f32</code>, <code>albedo: u32</code>, etc.) manually, including field type, size in bytes, and location in the vertex shader;</li>
<li>Repetitive using <code>include_glsl!</code> macro to compile shaders in <code>vertex()</code> and <code>fragment()</code> methods.</li>
</ol>
<p>All these problems can be solved by writing your own <code>Material</code> derive macro.</p>
<h2 id="macro-structue">Macro structue</h2>
<p>Let the declaration of our material be like:</p>
<pre data-lang="rust" style="background-color:#2b303b;color:#c0c5ce;" class="language-rust "><code class="language-rust" data-lang="rust"><span>#[</span><span style="color:#bf616a;">repr</span><span>(C)]
</span><span>#[</span><span style="color:#bf616a;">derive</span><span>(Material, Clone, Default, Debug, Serialize, Deserialize)]
</span><span style="color:#b48ead;">pub struct </span><span>MyMaterial {
</span><span>    </span><span style="color:#b48ead;">pub </span><span style="color:#bf616a;">color</span><span>: [</span><span style="color:#b48ead;">f32</span><span>; 3], </span><span style="color:#65737e;">// rgb-vector for color
</span><span>    </span><span style="color:#b48ead;">pub </span><span style="color:#bf616a;">albedo</span><span>: </span><span style="color:#b48ead;">u32</span><span>, </span><span style="color:#65737e;">// texture array index
</span><span>    </span><span style="color:#b48ead;">pub </span><span style="color:#bf616a;">blank</span><span>: </span><span style="color:#b48ead;">i32</span><span>, </span><span style="color:#65737e;">// just-for-test integer
</span><span>}
</span></code></pre>
<p>The basic functionality of the macro will include the creating input attributes for shaders based on the fields of the material structure, and the compilation of the shaders themselves. For this, we will add <code>material</code> attribute, which will include the paths to the vertex and fragment shaders. We will also add an optional parameter <code>topology</code> to specify the topology of rendering primitives (a list of triangles, lines, points, etc.), which will be equal to <code>&quot;triangle_list&quot;</code> by default:</p>
<pre data-lang="rust" style="background-color:#2b303b;color:#c0c5ce;" class="language-rust "><code class="language-rust" data-lang="rust"><span>#[</span><span style="color:#bf616a;">repr</span><span>(C)]
</span><span>#[</span><span style="color:#bf616a;">derive</span><span>(Material, Clone, Default, Debug, Serialize, Deserialize)]
</span><span>#[</span><span style="color:#bf616a;">material</span><span>(
</span><span>    vertex = &quot;</span><span style="color:#a3be8c;">examples/shaders/my_material.vs</span><span>&quot;,
</span><span>    fragment = &quot;</span><span style="color:#a3be8c;">examples/shaders/my_material.fs</span><span>&quot;,
</span><span>)]
</span><span style="color:#b48ead;">pub struct </span><span>MyMaterial {
</span><span>    </span><span style="color:#b48ead;">pub </span><span style="color:#bf616a;">color</span><span>: [</span><span style="color:#b48ead;">f32</span><span>; 3],
</span><span>    </span><span style="color:#b48ead;">pub </span><span style="color:#bf616a;">albedo</span><span>: </span><span style="color:#b48ead;">u32</span><span>,
</span><span>    </span><span style="color:#b48ead;">pub </span><span style="color:#bf616a;">blank</span><span>: </span><span style="color:#b48ead;">i32</span><span>,
</span><span>}
</span></code></pre>
<p>Also it would be nice to add automatic generation of Builder. Let's add parameters <code>#[color]</code> for the <code>color</code> field and <code>#[texture]</code> for the <code>albedo</code> field, which will tell the macro to replace the parameters of the builder functions with <code>Color&lt;f32&gt;</code> and <code>AssetHandle&lt;'T'&gt;</code> respectively. So, the final form of the declaration of our material will be as follows:</p>
<pre data-lang="rust" style="background-color:#2b303b;color:#c0c5ce;" class="language-rust "><code class="language-rust" data-lang="rust"><span>#[</span><span style="color:#bf616a;">repr</span><span>(C)]
</span><span>#[</span><span style="color:#bf616a;">derive</span><span>(Material, Clone, Default, Debug, Serialize, Deserialize)]
</span><span>#[</span><span style="color:#bf616a;">material</span><span>(
</span><span>    vertex = &quot;</span><span style="color:#a3be8c;">examples/shaders/my_material.vs</span><span>&quot;,
</span><span>    fragment = &quot;</span><span style="color:#a3be8c;">examples/shaders/my_material.fs</span><span>&quot;,
</span><span>)]
</span><span style="color:#b48ead;">pub struct </span><span>MyMaterial {
</span><span>    #[</span><span style="color:#bf616a;">color</span><span>]
</span><span>    </span><span style="color:#b48ead;">pub </span><span style="color:#bf616a;">color</span><span>: [</span><span style="color:#b48ead;">f32</span><span>; 3],
</span><span>    #[</span><span style="color:#bf616a;">texture</span><span>]
</span><span>    </span><span style="color:#b48ead;">pub </span><span style="color:#bf616a;">albedo</span><span>: </span><span style="color:#b48ead;">u32</span><span>,
</span><span>    </span><span style="color:#b48ead;">pub </span><span style="color:#bf616a;">blank</span><span>: </span><span style="color:#b48ead;">i32</span><span>,
</span><span>}
</span></code></pre>
<p>Now let's go directly to the macro implementation.</p>
<h2 id="implementation-of-material-trait-for-mymaterial">Implementation of Material trait for MyMaterial</h2>
<p>First, let's create a new crate <code>macros</code> and import the necessary modules into lib.rs, adding main derive function with the attributes material, texture and color:</p>
<pre data-lang="rust" style="background-color:#2b303b;color:#c0c5ce;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#b48ead;">use </span><span>core::panic;
</span><span>
</span><span style="color:#b48ead;">use </span><span>darling::FromDeriveInput;
</span><span style="color:#b48ead;">use </span><span>proc_macro::{</span><span style="color:#bf616a;">self</span><span>, TokenStream};
</span><span style="color:#b48ead;">use </span><span>proc_macro2::{Ident, Span};
</span><span style="color:#b48ead;">use </span><span>quote::{quote, ToTokens};
</span><span style="color:#b48ead;">use </span><span>syn::{parse_macro_input, Data, DeriveInput, Type, Meta, DataStruct, Field};
</span><span>
</span><span>#[</span><span style="color:#bf616a;">proc_macro_derive</span><span>(Material, </span><span style="color:#bf616a;">attributes</span><span>(material, texture, color))]
</span><span style="color:#b48ead;">pub fn </span><span style="color:#8fa1b3;">derive_material</span><span>(</span><span style="color:#bf616a;">input</span><span>: TokenStream) -&gt; TokenStream {
</span><span>    </span><span style="color:#b48ead;">let</span><span> input = parse_macro_input!(input as DeriveInput);
</span><span>    ...
</span><span>}
</span></code></pre>
<p>We will also add the <code>Opts</code> structure, where the material attributes will be stored:</p>
<pre data-lang="rust" style="background-color:#2b303b;color:#c0c5ce;" class="language-rust "><code class="language-rust" data-lang="rust"><span>#[</span><span style="color:#bf616a;">derive</span><span>(FromDeriveInput)]
</span><span>#[</span><span style="color:#bf616a;">darling</span><span>(</span><span style="color:#bf616a;">attributes</span><span>(material))]
</span><span style="color:#b48ead;">struct </span><span>Opts {
</span><span>    </span><span style="color:#bf616a;">vertex</span><span>: Option&lt;String&gt;,
</span><span>    </span><span style="color:#bf616a;">fragment</span><span>: Option&lt;String&gt;,
</span><span>    </span><span style="color:#bf616a;">topology</span><span>: Option&lt;String&gt;,
</span><span>}
</span></code></pre>
<p>Let us get the attributes of the material using <code>Opts::from_derive_input</code>; save its identifier in the <code>ident</code> variable and the data of the structure in the <code>data</code> variable, while restricting the use of the macro on types other than <code>struct</code> with the <code>let ... else</code> construction:</p>
<pre data-lang="rust" style="background-color:#2b303b;color:#c0c5ce;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#b48ead;">let</span><span> opts = Opts::from_derive_input(&amp;input).</span><span style="color:#96b5b4;">expect</span><span>(&quot;</span><span style="color:#a3be8c;">Wrong options</span><span>&quot;);
</span><span style="color:#b48ead;">let</span><span> ident = input.ident;
</span><span>
</span><span style="color:#b48ead;">let </span><span>Data::Struct(data) = input.data </span><span style="color:#b48ead;">else </span><span>{
</span><span>    panic!(&quot;</span><span style="color:#a3be8c;">Cannot make non-struct type into Material!</span><span>&quot;)
</span><span>};
</span></code></pre>
<p>Initial output of our macro (without builder generating) will look like this:</p>
<pre data-lang="rust" style="background-color:#2b303b;color:#c0c5ce;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#b48ead;">let</span><span> output = quote! {
</span><span>    #[::</span><span style="color:#bf616a;">flatbox</span><span>::</span><span style="color:#bf616a;">assets</span><span>::</span><span style="color:#bf616a;">typetag</span><span>::</span><span style="color:#bf616a;">serde</span><span>]
</span><span>    </span><span style="color:#b48ead;">impl </span><span>::flatbox::render::Material </span><span style="color:#b48ead;">for</span><span> #ident {
</span><span>        #vertex
</span><span>        #fragment
</span><span>        #input
</span><span>    }
</span><span>}
</span></code></pre>
<p>So, for this, create three variables: vertex, fragment and input, as well as the corresponding functions that will return <code>TokenStream</code>:</p>
<pre data-lang="rust" style="background-color:#2b303b;color:#c0c5ce;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#b48ead;">let</span><span> vertex = </span><span style="color:#96b5b4;">get_vertex_path</span><span>(&amp;opts);
</span><span style="color:#b48ead;">let</span><span> fragment = </span><span style="color:#96b5b4;">get_fragment_path</span><span>(&amp;opts);
</span><span style="color:#b48ead;">let</span><span> input = </span><span style="color:#96b5b4;">get_shader_input</span><span>(&amp;opts, &amp;data);
</span><span>
</span><span>...
</span><span>
</span><span style="color:#b48ead;">fn </span><span style="color:#8fa1b3;">get_vertex_path</span><span>(</span><span style="color:#bf616a;">opts</span><span>: &amp;Opts) -&gt; proc_macro2::TokenStream {...}
</span><span style="color:#b48ead;">fn </span><span style="color:#8fa1b3;">get_fragment_path</span><span>(</span><span style="color:#bf616a;">opts</span><span>: &amp;Opts) -&gt; proc_macro2::TokenStream {...}
</span><span style="color:#b48ead;">fn </span><span style="color:#8fa1b3;">get_shader_input</span><span>(</span><span style="color:#bf616a;">opts</span><span>: &amp;Opts, </span><span style="color:#bf616a;">data</span><span>: &amp;DataStruct) -&gt; proc_macro2::TokenStream {...}
</span></code></pre>
<p>With the help of <code>match</code> we get the path to the shader from the <code>vertex</code> and <code>fragment</code> attributes, and use it in another procedural macro <code>include_glsl!</code> from the crate <a href="https://crates.io/crates/vk-shader-macros"><code>vk-shader-macros</code></a>:</p>
<pre data-lang="rust" style="background-color:#2b303b;color:#c0c5ce;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#b48ead;">fn </span><span style="color:#8fa1b3;">get_vertex_path</span><span>(</span><span style="color:#bf616a;">opts</span><span>: &amp;Opts) -&gt; proc_macro2::TokenStream {
</span><span>    </span><span style="color:#b48ead;">match </span><span>&amp;opts.vertex {
</span><span>        Some(path) =&gt; quote! {
</span><span>            </span><span style="color:#b48ead;">fn </span><span style="color:#8fa1b3;">vertex</span><span>() -&gt; &amp;</span><span style="color:#b48ead;">&#39;static </span><span>[</span><span style="color:#b48ead;">u32</span><span>] {
</span><span>                ::flatbox::render::include_glsl!(
</span><span>                    #path, 
</span><span>                    kind: vert,
</span><span>                )
</span><span>            }
</span><span>        },
</span><span>        None =&gt; panic!(&quot;</span><span style="color:#a3be8c;">Use proc macro attribute #[material(vertex = </span><span style="color:#96b5b4;">\&quot;</span><span style="color:#a3be8c;">path</span><span style="color:#96b5b4;">\&quot;</span><span style="color:#a3be8c;">)] to set vertex shader path</span><span>&quot;),
</span><span>    }
</span><span>}
</span><span>
</span><span style="color:#b48ead;">fn </span><span style="color:#8fa1b3;">get_fragment_path</span><span>(</span><span style="color:#bf616a;">opts</span><span>: &amp;Opts) -&gt; proc_macro2::TokenStream {
</span><span>    </span><span style="color:#b48ead;">match </span><span>&amp;opts.fragment {
</span><span>        Some(path) =&gt; quote! {
</span><span>            </span><span style="color:#b48ead;">fn </span><span style="color:#8fa1b3;">fragment</span><span>() -&gt; &amp;</span><span style="color:#b48ead;">&#39;static </span><span>[</span><span style="color:#b48ead;">u32</span><span>] {
</span><span>                ::flatbox::render::include_glsl!(
</span><span>                    #path, 
</span><span>                    kind: frag,
</span><span>                )
</span><span>            }
</span><span>        },
</span><span>        None =&gt; panic!(&quot;</span><span style="color:#a3be8c;">Use proc macro attribute #[material(fragment = </span><span style="color:#96b5b4;">\&quot;</span><span style="color:#a3be8c;">path</span><span style="color:#96b5b4;">\&quot;</span><span style="color:#a3be8c;">)] to set fragment shader path</span><span>&quot;),
</span><span>    }
</span><span>}
</span></code></pre>
<p>The algorithm for generating shader input attributes will be a bit more complicated. To begin with, we need to get the topology of the primitives and the list of formats (types) of the structure fields that will be used by the shader.</p>
<pre data-lang="rust" style="background-color:#2b303b;color:#c0c5ce;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#b48ead;">fn </span><span style="color:#8fa1b3;">get_shader_input</span><span>(
</span><span>    </span><span style="color:#bf616a;">opts</span><span>: &amp;Opts,
</span><span>    </span><span style="color:#bf616a;">data</span><span>: &amp;DataStruct,
</span><span>) -&gt; proc_macro2::TokenStream {
</span><span>    </span><span style="color:#b48ead;">let</span><span> topology = ...;
</span><span>    </span><span style="color:#b48ead;">let</span><span> format = ...;
</span><span>
</span><span>    quote! {
</span><span>        </span><span style="color:#b48ead;">fn </span><span style="color:#8fa1b3;">input</span><span>() -&gt; ::flatbox::render::ShaderInput {
</span><span>            ...
</span><span>        }
</span><span>    }
</span><span>}
</span></code></pre>
<p>Get the topology in a way similar to how we got the path to shaders from the <code>Opts</code> structure:</p>
<pre data-lang="rust" style="background-color:#2b303b;color:#c0c5ce;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#b48ead;">let</span><span> topology = </span><span style="color:#b48ead;">match </span><span>&amp;opts.topology {
</span><span>    Some(topology) =&gt; </span><span style="color:#b48ead;">match</span><span> topology.</span><span style="color:#96b5b4;">as_str</span><span>() { </span><span style="color:#65737e;">// list all possible Vulkan topologies
</span><span>        &quot;</span><span style="color:#a3be8c;">point_list</span><span>&quot; =&gt; quote! { ::flatbox::render::ShaderTopology::</span><span style="color:#d08770;">POINT_LIST </span><span>},
</span><span>        &quot;</span><span style="color:#a3be8c;">line_list</span><span>&quot; =&gt; quote! { ::flatbox::render::ShaderTopology::</span><span style="color:#d08770;">LINE_LIST </span><span>},
</span><span>        &quot;</span><span style="color:#a3be8c;">line_strip</span><span>&quot; =&gt; quote! { ::flatbox::render::ShaderTopology::</span><span style="color:#d08770;">LINE_STRIP </span><span>},
</span><span>        &quot;</span><span style="color:#a3be8c;">triangle_list</span><span>&quot; =&gt; quote! { ::flatbox::render::ShaderTopology::</span><span style="color:#d08770;">TRIANGLE_LIST </span><span>},
</span><span>        &quot;</span><span style="color:#a3be8c;">triangle_strip</span><span>&quot; =&gt; quote! { ::flatbox::render::ShaderTopology::</span><span style="color:#d08770;">TRIANGLE_STRIP </span><span>},
</span><span>        &quot;</span><span style="color:#a3be8c;">triangle_fan</span><span>&quot; =&gt; quote! { ::flatbox::render::ShaderTopology::</span><span style="color:#d08770;">TRIANGLE_FAN </span><span>},
</span><span>        &quot;</span><span style="color:#a3be8c;">line_list_with_adjacency</span><span>&quot; =&gt; quote! { ::flatbox::render::ShaderTopology::</span><span style="color:#d08770;">LINE_LIST_WITH_ADJACENCY </span><span>},
</span><span>        &quot;</span><span style="color:#a3be8c;">line_strip_with_adjacency</span><span>&quot; =&gt; quote! { ::flatbox::render::ShaderTopology::</span><span style="color:#d08770;">LINE_STRIP_WITH_ADJACENCY </span><span>},
</span><span>        &quot;</span><span style="color:#a3be8c;">triangle_list_with_adjacency</span><span>&quot; =&gt; quote! { ::flatbox::render::ShaderTopology::</span><span style="color:#d08770;">TRIANGLE_LIST_WITH_ADJACENCY </span><span>},
</span><span>        &quot;</span><span style="color:#a3be8c;">triangle_strip_with_adjacency</span><span>&quot; =&gt; quote! { ::flatbox::render::ShaderTopology::</span><span style="color:#d08770;">TRIANGLE_STRIP_WITH_ADJACENCY </span><span>},
</span><span>        _ =&gt; panic!(&quot;</span><span style="color:#a3be8c;">Unsupported topology </span><span style="color:#96b5b4;">\&quot;</span><span style="color:#a3be8c;">{}</span><span style="color:#96b5b4;">\&quot;</span><span>&quot;, topology),
</span><span>    },
</span><span>    None =&gt; quote! { ::flatbox::render::ShaderTopology::</span><span style="color:#d08770;">TRIANGLE_LIST </span><span>}, </span><span style="color:#65737e;">// if the attribute is missing, then use the list of triangles (rendering of 3D models&#39; faces&#39; surface) by default
</span><span>};
</span></code></pre>
<p>To get a list of field formats, iterate over the <code>data.fields</code> structure and return <code>Map&lt;...&gt;</code>:</p>
<pre data-lang="rust" style="background-color:#2b303b;color:#c0c5ce;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#b48ead;">let</span><span> format = data.fields.</span><span style="color:#96b5b4;">iter</span><span>().</span><span style="color:#96b5b4;">map</span><span>(|</span><span style="color:#bf616a;">f</span><span>| {
</span><span>    </span><span style="color:#b48ead;">let</span><span> ty = &amp;f.ty;
</span><span>    </span><span style="color:#b48ead;">match</span><span> ty {
</span><span>        ...
</span><span>    }
</span><span>});
</span></code></pre>
<p>The list of types that can be used as shader input data is quite small: integers, floating-point numbers, and vectors - arrays of type [f32; 2], [f32; 3] and [f32; 4], i.e. several array types and simple types. Let's check the type of the <code>ty</code> field to see if it is an array or a regular type, and convert it to a string representation for further matching:</p>
<pre data-lang="rust" style="background-color:#2b303b;color:#c0c5ce;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#b48ead;">match</span><span> ty {
</span><span>    Type::Array(array) =&gt; { </span><span style="color:#65737e;">// whether array
</span><span>        </span><span style="color:#b48ead;">match</span><span> array.</span><span style="color:#96b5b4;">into_token_stream</span><span>().</span><span style="color:#96b5b4;">to_string</span><span>().</span><span style="color:#96b5b4;">as_str</span><span>() { </span><span style="color:#65737e;">// converting type to string
</span><span>            &quot;</span><span style="color:#a3be8c;">[f32 ; 2]</span><span>&quot; =&gt; quote! { ::flatbox::render::ShaderInputFormat::</span><span style="color:#d08770;">R32G32_SFLOAT </span><span>},
</span><span>            &quot;</span><span style="color:#a3be8c;">[f32 ; 3]</span><span>&quot; =&gt; quote! { ::flatbox::render::ShaderInputFormat::</span><span style="color:#d08770;">R32G32B32_SFLOAT </span><span>},
</span><span>            &quot;</span><span style="color:#a3be8c;">[f32 ; 4]</span><span>&quot; =&gt; quote! { ::flatbox::render::ShaderInputFormat::</span><span style="color:#d08770;">R32G32B32A32_SFLOAT </span><span>},
</span><span>            &quot;</span><span style="color:#a3be8c;">[f32 ; 1]</span><span>&quot; =&gt; quote! { ::flatbox::render::ShaderInputFormat::</span><span style="color:#d08770;">R32_SFLOAT </span><span>}, </span><span style="color:#65737e;">// array of one element is represented as an ordinary `float`
</span><span>            _ =&gt; panic!(&quot;</span><span style="color:#a3be8c;">Unsupported input format: </span><span style="color:#96b5b4;">\&quot;</span><span style="color:#a3be8c;">{}</span><span style="color:#96b5b4;">\&quot;</span><span>&quot;, array.</span><span style="color:#96b5b4;">into_token_stream</span><span>().</span><span style="color:#96b5b4;">to_string</span><span>().</span><span style="color:#96b5b4;">as_str</span><span>())
</span><span>        }
</span><span>    },
</span><span>    Type::Path(path) =&gt; { </span><span style="color:#65737e;">// whether regular type
</span><span>        </span><span style="color:#b48ead;">match</span><span> path.</span><span style="color:#96b5b4;">into_token_stream</span><span>().</span><span style="color:#96b5b4;">to_string</span><span>().</span><span style="color:#96b5b4;">as_str</span><span>() {
</span><span>            &quot;</span><span style="color:#a3be8c;">f32</span><span>&quot; =&gt; quote! { ::flatbox::render::ShaderInputFormat::</span><span style="color:#d08770;">R32_SFLOAT </span><span>},
</span><span>            &quot;</span><span style="color:#a3be8c;">u32</span><span>&quot; =&gt; quote! { ::flatbox::render::ShaderInputFormat::</span><span style="color:#d08770;">R8G8B8A8_UINT </span><span>},
</span><span>            &quot;</span><span style="color:#a3be8c;">i32</span><span>&quot; =&gt; quote! { ::flatbox::render::ShaderInputFormat::</span><span style="color:#d08770;">R8G8B8A8_SINT </span><span>},
</span><span>            _ =&gt; panic!(&quot;</span><span style="color:#a3be8c;">Unsupported input format: </span><span style="color:#96b5b4;">\&quot;</span><span style="color:#a3be8c;">{}</span><span style="color:#96b5b4;">\&quot;</span><span>&quot;, path.</span><span style="color:#96b5b4;">into_token_stream</span><span>().</span><span style="color:#96b5b4;">to_string</span><span>().</span><span style="color:#96b5b4;">as_str</span><span>())
</span><span>        }
</span><span>    },
</span><span>    _ =&gt; panic!(&quot;</span><span style="color:#a3be8c;">Unsupported input format</span><span>&quot;), </span><span style="color:#65737e;">// if the format of the field is different - panic!
</span><span>}
</span></code></pre>
<p>Now consider the <code>ShaderInput</code> structure:</p>
<pre data-lang="rust" style="background-color:#2b303b;color:#c0c5ce;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#b48ead;">pub struct </span><span>ShaderInput {
</span><span>    </span><span style="color:#b48ead;">pub </span><span style="color:#bf616a;">attributes</span><span>: Vec&lt;ShaderInputAttribute&gt;,
</span><span>    </span><span style="color:#b48ead;">pub </span><span style="color:#bf616a;">instance_size</span><span>: </span><span style="color:#b48ead;">usize</span><span>,
</span><span>    </span><span style="color:#b48ead;">pub </span><span style="color:#bf616a;">topology</span><span>: ShaderTopology,
</span><span>}
</span></code></pre>
<p>And also the internal <code>ShaderInputAttribute</code> structure:</p>
<pre data-lang="rust" style="background-color:#2b303b;color:#c0c5ce;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#b48ead;">pub struct </span><span>ShaderInputAttribute {
</span><span>    </span><span style="color:#b48ead;">pub </span><span style="color:#bf616a;">location</span><span>: </span><span style="color:#b48ead;">u32</span><span>,
</span><span>    </span><span style="color:#b48ead;">pub </span><span style="color:#bf616a;">binding</span><span>: </span><span style="color:#b48ead;">u32</span><span>,
</span><span>    </span><span style="color:#b48ead;">pub </span><span style="color:#bf616a;">format</span><span>: Format,
</span><span>    </span><span style="color:#b48ead;">pub </span><span style="color:#bf616a;">offset</span><span>: </span><span style="color:#b48ead;">u32</span><span>,
</span><span>}
</span></code></pre>
<p>If we have the topology and format of the fields, the <code>binding</code> is always constant, then we still need the offset of the input data, its location and the total size in bytes (instance_size). We can get all these values when iterating the field formats:</p>
<pre data-lang="rust" style="background-color:#2b303b;color:#c0c5ce;" class="language-rust "><code class="language-rust" data-lang="rust"><span>quote! {
</span><span>    </span><span style="color:#b48ead;">fn </span><span style="color:#8fa1b3;">input</span><span>() -&gt; ::flatbox::render::ShaderInput {
</span><span>        </span><span style="color:#b48ead;">let mut</span><span> location = </span><span style="color:#d08770;">3</span><span>; </span><span style="color:#65737e;">// location of the first parameter in the shader starting from &quot;0&quot; (the first 3 are occupied by the parameters of the 3D model itself)
</span><span>        </span><span style="color:#b48ead;">let mut</span><span> offset = </span><span style="color:#d08770;">0</span><span>; </span><span style="color:#65737e;">// offset of the first parameter (since the parameter is the first, therefore there is no offset)
</span><span>        </span><span style="color:#b48ead;">let mut</span><span> attributes = vec![];
</span><span>        #(
</span><span>            attributes.</span><span style="color:#96b5b4;">push</span><span>(
</span><span>                ::flatbox::render::ShaderInputAttribute{
</span><span>                    binding: </span><span style="color:#d08770;">1</span><span>,
</span><span>                    location: location,
</span><span>                    offset: offset,
</span><span>                    format: #format,
</span><span>                }
</span><span>            );
</span><span>
</span><span>            offset += </span><span style="color:#b48ead;">match </span><span>#format { </span><span style="color:#65737e;">// increase the offset of the next parameter by the size of the current one
</span><span>                ::flatbox::render::ShaderInputFormat::</span><span style="color:#d08770;">R8G8B8A8_UINT
</span><span>                    | ::flatbox::render::ShaderInputFormat::</span><span style="color:#d08770;">R8G8B8A8_SINT 
</span><span>                    | ::flatbox::render::ShaderInputFormat::</span><span style="color:#d08770;">R32_SFLOAT </span><span>=&gt; </span><span style="color:#d08770;">4</span><span>,
</span><span>                ::flatbox::render::ShaderInputFormat::</span><span style="color:#d08770;">R32G32_SFLOAT </span><span>=&gt; </span><span style="color:#d08770;">8</span><span>,
</span><span>                ::flatbox::render::ShaderInputFormat::</span><span style="color:#d08770;">R32G32B32_SFLOAT </span><span>=&gt; </span><span style="color:#d08770;">12</span><span>,
</span><span>                ::flatbox::render::ShaderInputFormat::</span><span style="color:#d08770;">R32G32B32A32_SFLOAT </span><span>=&gt; </span><span style="color:#d08770;">16</span><span>,
</span><span>                _ =&gt; </span><span style="color:#d08770;">0</span><span>,
</span><span>            };
</span><span>
</span><span>            location += </span><span style="color:#d08770;">1</span><span>; </span><span style="color:#65737e;">// increase the location of the next parameter by 1
</span><span>        )*
</span><span>        </span><span style="color:#b48ead;">let</span><span> instance_size = offset as </span><span style="color:#b48ead;">usize</span><span>; </span><span style="color:#65737e;">// at the end of the iterations, we set the total size of the data
</span><span>
</span><span>        ::flatbox::render::ShaderInput {
</span><span>            attributes,
</span><span>            instance_size,
</span><span>            topology: #topology,
</span><span>        }
</span><span>    }
</span><span>}
</span></code></pre>
<p>Well, now implementation of <code>Material</code> trait for your own type will be much easier. But do not forget about generation of the builder, which can make it even easier to create our custom materials.</p>
<h2 id="mymaterialbuilder-generating">MyMaterialBuilder generating</h2>
<p>Let's expand the output of our macro and add an implementation of builder creation:</p>
<pre data-lang="rust" style="background-color:#2b303b;color:#c0c5ce;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#b48ead;">let</span><span> output = quote! {
</span><span>    #[::</span><span style="color:#bf616a;">flatbox</span><span>::</span><span style="color:#bf616a;">assets</span><span>::</span><span style="color:#bf616a;">typetag</span><span>::</span><span style="color:#bf616a;">serde</span><span>]
</span><span>    </span><span style="color:#b48ead;">impl </span><span>::flatbox::render::Material </span><span style="color:#b48ead;">for</span><span> #ident {
</span><span>        #vertex
</span><span>        #fragment
</span><span>        #input
</span><span>    }
</span><span>
</span><span>    </span><span style="color:#b48ead;">impl </span><span>#ident {
</span><span>        </span><span style="color:#b48ead;">pub fn </span><span style="color:#8fa1b3;">builder</span><span>() -&gt; #ident_builder { </span><span style="color:#65737e;">// add builder initialization function to the material
</span><span>            #ident_builder::new()
</span><span>        }
</span><span>    }
</span><span>
</span><span>    #[</span><span style="color:#bf616a;">derive</span><span>(Clone, Default, Debug)]
</span><span>    </span><span style="color:#b48ead;">pub struct </span><span>#ident_builder { </span><span style="color:#65737e;">// generate builder struct
</span><span>        #(#fields,)*
</span><span>    }
</span><span>
</span><span>    </span><span style="color:#b48ead;">impl </span><span>#ident_builder {
</span><span>        </span><span style="color:#b48ead;">pub fn </span><span style="color:#8fa1b3;">new</span><span>() -&gt; </span><span style="color:#b48ead;">Self </span><span>{ </span><span style="color:#65737e;">// ...typical init function
</span><span>            </span><span style="color:#b48ead;">Self</span><span>::default()
</span><span>        }
</span><span>
</span><span>        </span><span style="color:#b48ead;">pub fn </span><span style="color:#8fa1b3;">build</span><span>(</span><span style="color:#bf616a;">self</span><span>) -&gt; #ident { </span><span style="color:#65737e;">// ...method that creates an instance of a material from builder data
</span><span>            #ident {
</span><span>                #(#build_function)*
</span><span>            }
</span><span>        }
</span><span>
</span><span>        #(#functions)* </span><span style="color:#65737e;">// and add builder configuration functions
</span><span>    }
</span><span>};
</span></code></pre>
<p>Now let's go seriatim. We need to create a builder ident. It's easy: just add the suffix &quot;Builder&quot; to the identifier of the structure. Let's do this using default <code>format!</code> macro:</p>
<pre data-lang="rust" style="background-color:#2b303b;color:#c0c5ce;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#b48ead;">let</span><span> ident_builder = Ident::new(format!(&quot;</span><span style="color:#d08770;">{}</span><span style="color:#a3be8c;">Builder</span><span>&quot;, ident.</span><span style="color:#96b5b4;">to_string</span><span>()).</span><span style="color:#96b5b4;">as_str</span><span>(), Span::call_site());
</span></code></pre>
<p>Next, we need to copy fields of the structure to the builder in order to use them during its initialization:</p>
<pre data-lang="rust" style="background-color:#2b303b;color:#c0c5ce;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#b48ead;">let</span><span> fields = data.fields.</span><span style="color:#96b5b4;">iter</span><span>().</span><span style="color:#96b5b4;">map</span><span>(|</span><span style="color:#bf616a;">f</span><span>| {
</span><span>    </span><span style="color:#b48ead;">let</span><span> name = &amp;f.ident;
</span><span>    </span><span style="color:#b48ead;">let</span><span> ty = &amp;f.ty;
</span><span>
</span><span>    quote! {
</span><span>        #name: #ty
</span><span>    }
</span><span>});
</span></code></pre>
<p>Create functions based on the names of the structure fields (<code>color()</code>, <code>albedo()</code>, etc.) for the builder configuration:</p>
<pre data-lang="rust" style="background-color:#2b303b;color:#c0c5ce;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#b48ead;">let</span><span> functions = data.fields.</span><span style="color:#96b5b4;">iter</span><span>().</span><span style="color:#96b5b4;">map</span><span>(|</span><span style="color:#bf616a;">f</span><span>| {
</span><span>    </span><span style="color:#b48ead;">let</span><span> name = &amp;f.ident;
</span><span>    </span><span style="color:#b48ead;">let</span><span> ty = &amp;f.ty;
</span><span>    </span><span style="color:#b48ead;">let</span><span> attr = </span><span style="color:#b48ead;">match</span><span> f.attrs.</span><span style="color:#96b5b4;">get</span><span>(</span><span style="color:#d08770;">0</span><span>) {
</span><span>        Some(attr) =&gt; {
</span><span>            ...
</span><span>        },
</span><span>        None =&gt; FieldAttribute::None,
</span><span>    };
</span><span>
</span><span>    ...
</span><span>});
</span></code></pre>
<p>For our convenience, let's create a enum <code>FieldAttribute</code>, which will determine which attribute was applied to current field (and whether it was):</p>
<pre data-lang="rust" style="background-color:#2b303b;color:#c0c5ce;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#b48ead;">enum </span><span>FieldAttribute {
</span><span>    Texture,
</span><span>    Color,
</span><span>    None,
</span><span>}
</span></code></pre>
<p>Then we are having:</p>
<pre data-lang="rust" style="background-color:#2b303b;color:#c0c5ce;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#b48ead;">let</span><span> attr = </span><span style="color:#b48ead;">match</span><span> f.attrs.</span><span style="color:#96b5b4;">get</span><span>(</span><span style="color:#d08770;">0</span><span>) {
</span><span>    Some(attr) =&gt; {
</span><span>        </span><span style="color:#b48ead;">if let </span><span>Meta::Path(path) = &amp;attr.meta {
</span><span>            </span><span style="color:#b48ead;">match</span><span> path.</span><span style="color:#96b5b4;">into_token_stream</span><span>().</span><span style="color:#96b5b4;">to_string</span><span>().</span><span style="color:#96b5b4;">as_str</span><span>() { </span><span style="color:#65737e;">// again we represent the tokens as a string
</span><span>                &quot;</span><span style="color:#a3be8c;">color</span><span>&quot; =&gt; FieldAttribute::Color,
</span><span>                &quot;</span><span style="color:#a3be8c;">texture</span><span>&quot; =&gt; FieldAttribute::Texture,
</span><span>                _ =&gt; panic!(&quot;</span><span style="color:#a3be8c;">Invalid field attribute: </span><span style="color:#96b5b4;">\&quot;</span><span style="color:#a3be8c;">{}</span><span style="color:#96b5b4;">\&quot;</span><span>&quot;, attr.</span><span style="color:#96b5b4;">into_token_stream</span><span>().</span><span style="color:#96b5b4;">to_string</span><span>().</span><span style="color:#96b5b4;">as_str</span><span>()),
</span><span>            }
</span><span>        } </span><span style="color:#b48ead;">else </span><span>{
</span><span>            panic!(&quot;</span><span style="color:#a3be8c;">Invalid field attribute: </span><span style="color:#96b5b4;">\&quot;</span><span style="color:#a3be8c;">{}</span><span style="color:#96b5b4;">\&quot;</span><span>&quot;, attr.</span><span style="color:#96b5b4;">into_token_stream</span><span>().</span><span style="color:#96b5b4;">to_string</span><span>().</span><span style="color:#96b5b4;">as_str</span><span>());
</span><span>        }
</span><span>    },
</span><span>    None =&gt; FieldAttribute::None,
</span><span>    
</span><span>    ...
</span><span>};
</span></code></pre>
<p>And now we check the attributes for the precise generation of our function:</p>
<pre data-lang="rust" style="background-color:#2b303b;color:#c0c5ce;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#b48ead;">match</span><span> attr {
</span><span>    FieldAttribute::Color =&gt; quote! {
</span><span>        </span><span style="color:#b48ead;">pub fn </span><span>#</span><span style="color:#96b5b4;">name</span><span>(</span><span style="color:#b48ead;">mut </span><span style="color:#bf616a;">self</span><span>, value: ::flatbox::render::Color&lt;</span><span style="color:#b48ead;">f32</span><span>&gt;) -&gt; </span><span style="color:#b48ead;">Self </span><span>{ 
</span><span>            </span><span style="color:#bf616a;">self</span><span>.#name = value.</span><span style="color:#96b5b4;">into</span><span>();
</span><span>            </span><span style="color:#bf616a;">self
</span><span>        }
</span><span>    },
</span><span>    FieldAttribute::Texture =&gt; quote! {
</span><span>        </span><span style="color:#b48ead;">pub fn </span><span>#</span><span style="color:#96b5b4;">name</span><span>(</span><span style="color:#b48ead;">mut </span><span style="color:#bf616a;">self</span><span>, value: ::flatbox::assets::AssetHandle&lt;&#39;T&#39;&gt;) -&gt; </span><span style="color:#b48ead;">Self </span><span>{ 
</span><span>            </span><span style="color:#bf616a;">self</span><span>.#name = value.</span><span style="color:#96b5b4;">into</span><span>();
</span><span>            </span><span style="color:#bf616a;">self
</span><span>        }
</span><span>    },
</span><span>    _ =&gt; quote! {
</span><span>        </span><span style="color:#b48ead;">pub fn </span><span>#</span><span style="color:#96b5b4;">name</span><span>(</span><span style="color:#b48ead;">mut </span><span style="color:#bf616a;">self</span><span>, value: #ty) -&gt; </span><span style="color:#b48ead;">Self </span><span>{ 
</span><span>            </span><span style="color:#bf616a;">self</span><span>.#name = value;
</span><span>            </span><span style="color:#bf616a;">self
</span><span>        }
</span><span>    },
</span><span>}
</span></code></pre>
<p>And finally, for the <code>build()</code> function, we will generate the &quot;assignment&quot; of the values of the builder fields to the fields of our new material:</p>
<pre data-lang="rust" style="background-color:#2b303b;color:#c0c5ce;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#b48ead;">let</span><span> build_function = data.fields.</span><span style="color:#96b5b4;">iter</span><span>().</span><span style="color:#96b5b4;">map</span><span>(|</span><span style="color:#bf616a;">f</span><span>| {
</span><span>    </span><span style="color:#b48ead;">let</span><span> name = &amp;f.ident;
</span><span>    quote! {
</span><span>        #name: </span><span style="color:#bf616a;">self</span><span>.#name,
</span><span>    }
</span><span>});
</span></code></pre>
<h2 id="conclusion">Conclusion</h2>
<p>So what do we have?</p>
<ol>
<li>Easy creating material field attributes for their use in shaders;</li>
<li>Automatic generation of the material builder for its quick initialization.</li>
</ol>
<p>What else can be done?</p>
<p>As an example, you can add the <code>#[default = ...]</code> field attribute, which will set the default field values in the builder when it is created.</p>
<p>You can find the complete macro code <a href="https://github.com/konceptosociala/flatbox/blob/main/macros/src/lib.rs">at the link</a>.</p>

</div>

<script src="https://utteranc.es/client.js"
        repo="konceptosociala&#x2F;konceptosociala.github.io"
        issue-term="pathname"
        
        label="KS Comment"
        
        theme="photon-dark"
        crossorigin="anonymous"
        async>
</script>


        
    </div>
    <div class="curve-section">
        <svg data-name="Layer 1" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 1200 120" preserveAspectRatio="none">
            <path d="M1200 120L0 16.48 0 0 1200 0 1200 120z" class="shape-fill" style="fill: #393C44"></path>
        </svg>
    </div>
</section>


    <footer class="d-flex flex-wrap justify-content-between align-items-center" style="background: #1D1E23">
        <div class="col-md-4 d-flex align-items-center">
            <a href="/" class="mb-3 me-2 mb-md-0 text-light text-decoration-none lh-1">
                <svg class="bi" width="30" height="24"><use xlink:href="#bootstrap"></use></svg>
            </a>
            <span class="text-light">Koncepto Sociala © 2023</span>
        </div>
      
        <ul class="nav p-3 col-md-4 justify-content-end list-unstyled d-flex">
            <li class="ms-3"><a title="GitHub" class="fa fa-github social" href="https:&#x2F;&#x2F;github.com&#x2F;konceptosociala&#x2F;"></a></li>
            <li class="ms-3"><a title="E-mail" class="fa fa-email-bulk social" href="mailto:sanerhp.mail@gmail.com"></a></li>
            <li class="ms-3"><a title="Telegram" class="fa fa-telegram social" href="https:&#x2F;&#x2F;t.me&#x2F;ksociala_official"></a></li>
            
            
            
            
            
            
            
        </ul>
    </footer> 

    
    <script src="https://ajax.googleapis.com/ajax/libs/jquery/3.7.0/jquery.min.js"></script> 
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/js/bootstrap.bundle.min.js" integrity="sha384-geWF76RCwLtnZ8qwWowPQNguL3RmwHVBC9FhGdlKrxdiJJigb/j/68SIy3Te4Bkz" crossorigin="anonymous"></script>
    <script src="
    
        https://konceptosociala.eu.org/js/script.js
    
"></script>
</body>
</html>