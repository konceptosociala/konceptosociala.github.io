<!DOCTYPE html>
<html lang="en" style="
    --socio-text-color: #F5F5F5;
    --socio-link-color: #FFF;
    --socio-code-color: #FFF;
    --socio-code-bg: #1D1E23;
">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">

    <meta name="description" content="ПОПЕРЕДЖЕННЯ: у цій статті йдеться про стару версію крейту flatbox, яку зараз повністю переписано.
Крейт Flatbox містить досить корисний трейт Material, який дозволяє розробнику створювати власні матеріали на основі шейдерів GLSL. Його приблизна реалізація…"/>

    <meta property="og:url" content="https:&#x2F;&#x2F;konceptosociala.eu.org&#x2F;ua&#x2F;blog&#x2F;material-proc-macro&#x2F;" />
    <meta property="og:title" content="Процедурний макрос Material для Flatbox |Koncepto Sociala" />
    <meta property="og:type" content="website" />
    <meta property="og:description" content="ПОПЕРЕДЖЕННЯ: у цій статті йдеться про стару версію крейту flatbox, яку зараз повністю переписано.
Крейт Flatbox містить досить корисний трейт Material, який дозволяє розробнику створювати власні матеріали на основі шейдерів GLSL. Його приблизна реалізація…" />
    <meta property="og:image" content="https://konceptosociala.eu.org/img/ks.svg" />

    <meta property="twitter:domain" content="konceptosociala.eu.org">
    <meta property="twitter:url" content="https:&#x2F;&#x2F;konceptosociala.eu.org&#x2F;ua&#x2F;blog&#x2F;material-proc-macro&#x2F;">
    <meta name="twitter:title" content="Процедурний макрос Material для Flatbox |Koncepto Sociala">
    <meta name="twitter:description" content="ПОПЕРЕДЖЕННЯ: у цій статті йдеться про стару версію крейту flatbox, яку зараз повністю переписано.
Крейт Flatbox містить досить корисний трейт Material, який дозволяє розробнику створювати власні матеріали на основі шейдерів GLSL. Його приблизна реалізація…">
    <meta name="twitter:image" content="https://konceptosociala.eu.org/img/ks.svg"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/lipis/flag-icons@6.6.6/css/flag-icons.min.css"/><link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css" rel="stylesheet" integrity="sha384-9ndCyUaIbzAi2FUVXJi0CjmCapSmO7SnpJef0486qhLnuZ2cdeRhO02iuK6FUUVM" crossorigin="anonymous">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/fork-awesome@1.2.0/css/fork-awesome.min.css" integrity="sha256-XoaMnoYC5TH6/+ihMEnospgm0J1PM/nioxbOUdnM8HY=" crossorigin="anonymous">
    <link href="https://konceptosociala.eu.org/navbar.css" rel="stylesheet" type="text/css">
    <link href="https://konceptosociala.eu.org/theme.css" rel="stylesheet" type="text/css">
    <link rel="shortcut icon" href="https://konceptosociala.eu.org/img/ks.svg" type="image/x-icon"><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/4.1.1/animate.min.css"/><title>Процедурний макрос Material для Flatbox |Koncepto Sociala</title>
</head>
<body>
    <header>
        <nav class="navbar navbar-expand-lg navbar-dark" style="background: #0F0F11;">
            <div class="container-fluid">
                <a class="navbar-brand" href="https://konceptosociala.eu.org/ua"><img src="https://konceptosociala.eu.org/img/ks.svg" alt="Website logo" height="35"></a>
                <a class="navicon-button plus d-lg-none" data-bs-toggle="collapse" data-bs-target="#navbarSupportedContent" aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
                    <div class="navicon"></div>
                </a>
                <div class="collapse navbar-collapse" id="navbarSupportedContent">
                    <ul class="navbar-nav me-auto mb-2 mb-lg-0"><li class="nav-item">
                                    <a class="nav-link" aria-current="page" href="https://konceptosociala.eu.org/ua">Головна</a>
                                </li><li class="nav-item">
                                    <a class="nav-link" aria-current="page" href="https://konceptosociala.eu.org/ua/blog">Блог</a>
                                </li><li class="nav-item dropdown">
                                    <a class="nav-link dropdown-toggle" href="#" role="button" data-bs-toggle="dropdown" aria-expanded="false">
                                        Ігри
                                    </a>
                                    <ul class="dropdown-menu"><li><a class="dropdown-item" href="https://konceptosociala.eu.org/ua/games/komunterio">Komunterio</a></li></ul>
                                </li><li class="nav-item dropdown">
                                    <a class="nav-link dropdown-toggle" href="#" role="button" data-bs-toggle="dropdown" aria-expanded="false">
                                        ПЗ
                                    </a>
                                    <ul class="dropdown-menu"><li><a class="dropdown-item" href="https://konceptosociala.eu.org/ua/software/flatbox">Flatbox</a></li><li><a class="dropdown-item" href="https://konceptosociala.eu.org/ua/software/flatbox-doryen">Flatbox Doryen</a></li></ul>
                                </li><li class="nav-item">
                                    <a class="nav-link" aria-current="page" href="https://konceptosociala.eu.org/ua/music">Музика</a>
                                </li><li class="nav-item">
                                    <a class="nav-link" aria-current="page" href="https://github.com/konceptosociala">GitHub</a>
                                </li><li class="nav-item">
                                    <a class="nav-link" aria-current="page" href="https://konceptosociala.eu.org/ua/about">Інфо</a>
                                </li><li class="nav-item dropdown">
                            <a class="nav-link dropdown-toggle fa fa-globe mt-1" href="#" role="button" data-bs-toggle="dropdown" aria-expanded="false">
                                <span class="d-lg-none text-uppercase"> ua</span>
                            </a>
                            <ul class="dropdown-menu"><li><a class="dropdown-item" href="https:&#x2F;&#x2F;konceptosociala.eu.org&#x2F;blog&#x2F;material-proc-macro"><span class="fi fi-us"></span>
                                        English
                                    </a></li><li><a class="dropdown-item" href="https:&#x2F;&#x2F;konceptosociala.eu.org&#x2F;ua&#x2F;blog&#x2F;material-proc-macro"><span class="fi fi-ua"></span>
                                        Українська
                                    </a></li><li><a class="dropdown-item" href="https:&#x2F;&#x2F;konceptosociala.eu.org&#x2F;ru&#x2F;blog&#x2F;material-proc-macro"><span class="fi fi-ua"></span>
                                        Русский
                                    </a></li><li><a class="dropdown-item" href="https:&#x2F;&#x2F;konceptosociala.eu.org&#x2F;eo&#x2F;blog&#x2F;material-proc-macro"><span class="fi fi-un"></span>
                                        Esperanto
                                    </a></li></ul>
                        </li></ul>
                </div>
            </div>
        </nav>
        <div class="curve-header">
            <svg data-name="Layer 1" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 1200 120" preserveAspectRatio="none">
                <path d="M0,0V46.29c47.79,22.2,103.59,32.17,158,28,70.36-5.37,136.33-33.31,206.8-37.5C438.64,32.43,512.34,53.67,583,72.05c69.27,18,138.3,24.88,209.4,13.08,36.15-6,69.85-17.84,104.45-29.34C989.49,25,1113-14.29,1200,52.47V0Z" opacity=".25" class="shape-fill" style="fill: #0F0F11"></path>
                <path d="M0,0V15.81C13,36.92,27.64,56.86,47.69,72.05,99.41,111.27,165,111,224.58,91.58c31.15-10.15,60.09-26.07,89.67-39.8,40.92-19,84.73-46,130.83-49.67,36.26-2.85,70.9,9.42,98.6,31.56,31.77,25.39,62.32,62,103.63,73,40.44,10.79,81.35-6.69,119.13-24.28s75.16-39,116.92-43.05c59.73-5.85,113.28,22.88,168.9,38.84,30.2,8.66,59,6.17,87.09-7.5,22.43-10.89,48-26.93,60.65-49.24V0Z" opacity=".5" class="shape-fill" style="fill: #0F0F11"></path>
                <path d="M0,0V5.63C149.93,59,314.09,71.32,475.83,42.57c43-7.64,84.23-20.12,127.61-26.46,59-8.63,112.48,12.24,165.56,35.4C827.93,77.22,886,95.24,951.2,90c86.53-7,172.46-45.71,248.8-84.81V0Z" class="shape-fill" style="fill: #0F0F11"></path>
            </svg>
        </div>
    </header><section class="section" style="background: #393C44;">
    <div class="container content" style="min-height: 90vh;"><div class="post px-lg-5 mx-lg-5 mt-3">
    <p class="date">~~ 2023-07-21 ~~</p>
    <h1 class="title">Процедурний макрос Material для Flatbox</h1>
    <hr class="big-hr">
    <p><strong>ПОПЕРЕДЖЕННЯ</strong>: у цій статті йдеться про стару версію крейту <code>flatbox</code>, яку зараз повністю переписано.</p>
<p>Крейт Flatbox містить досить корисний трейт <code>Material</code>, який дозволяє розробнику створювати власні матеріали на основі шейдерів GLSL. Його приблизна реалізація для кастомного матеріалу <code>MyMaterial</code> на початку виглядала так:</p>
<pre data-lang="rust" style="background-color:#2b303b;color:#c0c5ce;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#65737e;">// Typetag використовуємо для серіалізації колекції матеріалів `Vec&lt;Arc&lt;dyn Material&gt;&gt;`
</span><span>#[</span><span style="color:#bf616a;">typetag</span><span>::</span><span style="color:#bf616a;">serde</span><span>]
</span><span style="color:#b48ead;">impl </span><span>Material </span><span style="color:#b48ead;">for </span><span>MyMaterial {
</span><span>    </span><span style="color:#b48ead;">fn </span><span style="color:#8fa1b3;">pipeline</span><span>(</span><span style="color:#bf616a;">renderer</span><span>: &amp;Renderer) -&gt; Pipeline {      
</span><span>        </span><span style="color:#65737e;">// Опис вхідних даних шейдера
</span><span>        </span><span style="color:#b48ead;">let</span><span> instance_attributes = vec![
</span><span>            ShaderInputAttribute{
</span><span>                binding: </span><span style="color:#d08770;">1</span><span>,
</span><span>                location: </span><span style="color:#d08770;">3</span><span>,
</span><span>                offset: </span><span style="color:#d08770;">0</span><span>,
</span><span>                format: ShaderInputFormat::</span><span style="color:#d08770;">R32G32B32_SFLOAT</span><span>,
</span><span>            },
</span><span>            ShaderInputAttribute{
</span><span>                binding: </span><span style="color:#d08770;">1</span><span>,
</span><span>                location: </span><span style="color:#d08770;">4</span><span>,
</span><span>                offset: </span><span style="color:#d08770;">12</span><span>,
</span><span>                format: ShaderInputFormat::</span><span style="color:#d08770;">R8G8B8A8_UINT</span><span>,
</span><span>            },
</span><span>            ...
</span><span>        ];
</span><span>        
</span><span>        </span><span style="color:#65737e;">// Створення вертекс-шейдера
</span><span>        </span><span style="color:#b48ead;">let</span><span> vertex_shader = vk::ShaderModuleCreateInfo::builder()
</span><span>            .</span><span style="color:#96b5b4;">code</span><span>(vk_shader_macros::include_glsl!(
</span><span>                &quot;</span><span style="color:#a3be8c;">./src/shaders/vertex_combined.glsl</span><span>&quot;, 
</span><span>                kind: vert,
</span><span>            ));
</span><span>        
</span><span>        </span><span style="color:#65737e;">// Створення фрагмент-шейдера
</span><span>        </span><span style="color:#b48ead;">let</span><span> fragment_shader = vk::ShaderModuleCreateInfo::builder()
</span><span>            .</span><span style="color:#96b5b4;">code</span><span>(vk_shader_macros::include_glsl!(
</span><span>                &quot;</span><span style="color:#a3be8c;">./src/shaders/fragment_combined.glsl</span><span>&quot;,
</span><span>                kind: frag,
</span><span>            ));
</span><span>        
</span><span>        </span><span style="color:#65737e;">// Ручна ініціалізація графічного пайплайну
</span><span>        Pipeline::init(
</span><span>            &amp;renderer,
</span><span>            &amp;vertex_shader,
</span><span>            &amp;fragment_shader,
</span><span>            instance_attributes,
</span><span>            </span><span style="color:#d08770;">40</span><span>,
</span><span>            ShaderTopology::</span><span style="color:#d08770;">TRIANGLE_LIST</span><span>,
</span><span>        ).</span><span style="color:#96b5b4;">expect</span><span>(&quot;</span><span style="color:#a3be8c;">Cannot create pipeline</span><span>&quot;)
</span><span>    }
</span><span>}
</span></code></pre>
<p>Тобто розробник мав власноруч створювати шейдери і графічні пайплайни для кожного матеріала, що було б досить неефективно, так як довелося б писати велику кількість повторюваного і відносно низькорівневого коду. Таким чином є доречним розділити трейт <code>Material</code> на кілька методів:</p>
<pre data-lang="rust" style="background-color:#2b303b;color:#c0c5ce;" class="language-rust "><code class="language-rust" data-lang="rust"><span>#[</span><span style="color:#bf616a;">typetag</span><span>::</span><span style="color:#bf616a;">serde</span><span>(tag = &quot;</span><span style="color:#a3be8c;">material</span><span>&quot;)]
</span><span style="color:#b48ead;">pub trait </span><span>Material: AsAny + std::fmt::Debug + Send + Sync {
</span><span>    </span><span style="color:#b48ead;">fn </span><span style="color:#8fa1b3;">vertex</span><span>() -&gt; &amp;</span><span style="color:#b48ead;">&#39;static </span><span>[</span><span style="color:#b48ead;">u32</span><span>]
</span><span>    </span><span style="color:#b48ead;">where 
</span><span>        </span><span style="color:#b48ead;">Self</span><span>: Sized;
</span><span>
</span><span>    </span><span style="color:#b48ead;">fn </span><span style="color:#8fa1b3;">fragment</span><span>() -&gt; &amp;</span><span style="color:#b48ead;">&#39;static </span><span>[</span><span style="color:#b48ead;">u32</span><span>]
</span><span>    </span><span style="color:#b48ead;">where 
</span><span>        </span><span style="color:#b48ead;">Self</span><span>: Sized;
</span><span>
</span><span>    </span><span style="color:#b48ead;">fn </span><span style="color:#8fa1b3;">input</span><span>() -&gt; ShaderInput
</span><span>    </span><span style="color:#b48ead;">where 
</span><span>        </span><span style="color:#b48ead;">Self</span><span>: Sized;
</span><span>}
</span></code></pre>
<p>, де <code>ShaderInput</code> буде структурою даних, що зберігатиме необхідні атрибути для створення графічного пайплайну:</p>
<pre data-lang="rust" style="background-color:#2b303b;color:#c0c5ce;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#b48ead;">pub struct </span><span>ShaderInput {
</span><span>    </span><span style="color:#b48ead;">pub </span><span style="color:#bf616a;">attributes</span><span>: Vec&lt;ShaderInputAttribute&gt;,
</span><span>    </span><span style="color:#b48ead;">pub </span><span style="color:#bf616a;">instance_size</span><span>: </span><span style="color:#b48ead;">usize</span><span>,
</span><span>    </span><span style="color:#b48ead;">pub </span><span style="color:#bf616a;">topology</span><span>: ShaderTopology,
</span><span>}
</span></code></pre>
<p>Все інше перемістимо до методу прив'язки кастомного матеріалу до рендерера:</p>
<pre data-lang="rust" style="background-color:#2b303b;color:#c0c5ce;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#b48ead;">pub fn </span><span style="color:#8fa1b3;">bind_material</span><span>&lt;M: Material + Sync + Send&gt;(&amp;</span><span style="color:#b48ead;">mut </span><span style="color:#bf616a;">self</span><span>){
</span><span>    </span><span style="color:#65737e;">// Перевірка чи матеріал вже прив&#39;язаний
</span><span>    </span><span style="color:#b48ead;">if </span><span style="color:#bf616a;">self</span><span>.material_pipelines.</span><span style="color:#96b5b4;">contains_key</span><span>(&amp;TypeId::of::&lt;M&gt;()) {
</span><span>        log::error!(&quot;</span><span style="color:#a3be8c;">Material type &#39;{}&#39; is already bound!</span><span>&quot;, std::any::type_name::&lt;M&gt;());
</span><span>    } </span><span style="color:#b48ead;">else </span><span>{        
</span><span>        </span><span style="color:#65737e;">// Створення шейдерів та ін.        
</span><span>        </span><span style="color:#b48ead;">let</span><span> vertex_shader = vk::ShaderModuleCreateInfo::builder().</span><span style="color:#96b5b4;">code</span><span>(M::vertex());
</span><span>        </span><span style="color:#b48ead;">let</span><span> fragment_shader = vk::ShaderModuleCreateInfo::builder().</span><span style="color:#96b5b4;">code</span><span>(M::fragment());
</span><span>        </span><span style="color:#b48ead;">let</span><span> shader_input = M::input();
</span><span>        
</span><span>        </span><span style="color:#65737e;">// Створення пайплайну
</span><span>        </span><span style="color:#b48ead;">let</span><span> pipeline = Pipeline::init(
</span><span>            &amp;</span><span style="color:#bf616a;">self</span><span>,
</span><span>            &amp;vertex_shader,
</span><span>            &amp;fragment_shader,
</span><span>            &amp;shader_input.attributes,
</span><span>            shader_input.instance_size,
</span><span>            shader_input.topology
</span><span>        ).</span><span style="color:#96b5b4;">expect</span><span>(&quot;</span><span style="color:#a3be8c;">Cannot create pipeline</span><span>&quot;);
</span><span>
</span><span>        </span><span style="color:#bf616a;">self</span><span>.material_pipelines.</span><span style="color:#96b5b4;">insert</span><span>(TypeId::of::&lt;M&gt;(), pipeline);
</span><span>    }
</span><span>}
</span></code></pre>
<p>Наразі реалізація кастомних матеріалів стала більш простою, проте все ще залишаються невирішеними кілька проблем:</p>
<ol>
<li>Необхідність описувати кожне поле матеріалу (наприклад, <code>roughness: f32</code>, <code>albedo: u32</code> тощо) вручну, включаючи тип поля, розмір у байтах та положення у вершинному шейдері;</li>
<li>Повторюване використання макросу <code>include_glsl!</code> для компіляції шейдерів у методах <code>vertex()</code> та <code>fragment()</code>.</li>
</ol>
<p>Усі ці проблеми можна вирішити за допомогою написання власного derive-макросу <code>Material</code>.</p>
<h2 id="struktura-makrosu">Структура макросу</h2>
<p>Нехай оголошення нашого матеріалу буде таким: </p>
<pre data-lang="rust" style="background-color:#2b303b;color:#c0c5ce;" class="language-rust "><code class="language-rust" data-lang="rust"><span>#[</span><span style="color:#bf616a;">repr</span><span>(C)]
</span><span>#[</span><span style="color:#bf616a;">derive</span><span>(Material, Clone, Default, Debug, Serialize, Deserialize)]
</span><span style="color:#b48ead;">pub struct </span><span>MyMaterial {
</span><span>    </span><span style="color:#b48ead;">pub </span><span style="color:#bf616a;">color</span><span>: [</span><span style="color:#b48ead;">f32</span><span>; 3], </span><span style="color:#65737e;">// rgb-вектор для кольору
</span><span>    </span><span style="color:#b48ead;">pub </span><span style="color:#bf616a;">albedo</span><span>: </span><span style="color:#b48ead;">u32</span><span>, </span><span style="color:#65737e;">// індекс масиву текстур
</span><span>    </span><span style="color:#b48ead;">pub </span><span style="color:#bf616a;">blank</span><span>: </span><span style="color:#b48ead;">i32</span><span>, </span><span style="color:#65737e;">// знакове ціле число для тесту
</span><span>}
</span></code></pre>
<p>Базовий функціонал макросу включатиме в себе створення атрибутів вхідних даних шейдерів на основі полів структури матеріалу і компіляцію самих шейдерів. Для цього додамо атрибут <code>material</code>, що буде включати шляхи до вершинного (<code>vertex</code>) та фрагментного (<code>fragment</code>) шейдерів. Також додамо опціональний параметр <code>topology</code>, щоб вказати топологію рендерінгу примітивів (список трикутників, ліній, точок тощо), що за замовчуванням буде дорівнювати <code>&quot;triangle_list&quot;</code>:</p>
<pre data-lang="rust" style="background-color:#2b303b;color:#c0c5ce;" class="language-rust "><code class="language-rust" data-lang="rust"><span>#[</span><span style="color:#bf616a;">repr</span><span>(C)]
</span><span>#[</span><span style="color:#bf616a;">derive</span><span>(Material, Clone, Default, Debug, Serialize, Deserialize)]
</span><span>#[</span><span style="color:#bf616a;">material</span><span>(
</span><span>    vertex = &quot;</span><span style="color:#a3be8c;">examples/shaders/my_material.vs</span><span>&quot;,
</span><span>    fragment = &quot;</span><span style="color:#a3be8c;">examples/shaders/my_material.fs</span><span>&quot;,
</span><span>)]
</span><span style="color:#b48ead;">pub struct </span><span>MyMaterial {
</span><span>    </span><span style="color:#b48ead;">pub </span><span style="color:#bf616a;">color</span><span>: [</span><span style="color:#b48ead;">f32</span><span>; 3],
</span><span>    </span><span style="color:#b48ead;">pub </span><span style="color:#bf616a;">albedo</span><span>: </span><span style="color:#b48ead;">u32</span><span>,
</span><span>    </span><span style="color:#b48ead;">pub </span><span style="color:#bf616a;">blank</span><span>: </span><span style="color:#b48ead;">i32</span><span>,
</span><span>}
</span></code></pre>
<p>Ще було б непогано додати автоматичну генерацію білдеру. Додамо параметри <code>#[color]</code> для поля <code>color</code> і <code>#[texture]</code> для поля <code>albedo</code>, що будуть вказувати макросу замінити параметри функцій білдеру на <code>Color&lt;f32&gt;</code> і <code>AssetHandle&lt;'T'&gt;</code> відповідно. Отже, кінцевий вид декларації нашого матеріалу буде таким:</p>
<pre data-lang="rust" style="background-color:#2b303b;color:#c0c5ce;" class="language-rust "><code class="language-rust" data-lang="rust"><span>#[</span><span style="color:#bf616a;">repr</span><span>(C)]
</span><span>#[</span><span style="color:#bf616a;">derive</span><span>(Material, Clone, Default, Debug, Serialize, Deserialize)]
</span><span>#[</span><span style="color:#bf616a;">material</span><span>(
</span><span>    vertex = &quot;</span><span style="color:#a3be8c;">examples/shaders/my_material.vs</span><span>&quot;,
</span><span>    fragment = &quot;</span><span style="color:#a3be8c;">examples/shaders/my_material.fs</span><span>&quot;,
</span><span>)]
</span><span style="color:#b48ead;">pub struct </span><span>MyMaterial {
</span><span>    #[</span><span style="color:#bf616a;">color</span><span>]
</span><span>    </span><span style="color:#b48ead;">pub </span><span style="color:#bf616a;">color</span><span>: [</span><span style="color:#b48ead;">f32</span><span>; 3],
</span><span>    #[</span><span style="color:#bf616a;">texture</span><span>]
</span><span>    </span><span style="color:#b48ead;">pub </span><span style="color:#bf616a;">albedo</span><span>: </span><span style="color:#b48ead;">u32</span><span>,
</span><span>    </span><span style="color:#b48ead;">pub </span><span style="color:#bf616a;">blank</span><span>: </span><span style="color:#b48ead;">i32</span><span>,
</span><span>}
</span></code></pre>
<p>Тепер перейдемо безпосередньо до реалізації макросу.</p>
<h2 id="implementatsiia-treitu-material-dlia-mymaterial">Імплементація трейту Material для MyMaterial</h2>
<p>Спочатку створимо новий крейт <code>macros</code> і в lib.rs одразу імпортуємо необхідні модулі та додамо основну derive-функцію з атрибутами material, texture та color:</p>
<pre data-lang="rust" style="background-color:#2b303b;color:#c0c5ce;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#b48ead;">use </span><span>core::panic;
</span><span>
</span><span style="color:#b48ead;">use </span><span>darling::FromDeriveInput;
</span><span style="color:#b48ead;">use </span><span>proc_macro::{</span><span style="color:#bf616a;">self</span><span>, TokenStream};
</span><span style="color:#b48ead;">use </span><span>proc_macro2::{Ident, Span};
</span><span style="color:#b48ead;">use </span><span>quote::{quote, ToTokens};
</span><span style="color:#b48ead;">use </span><span>syn::{parse_macro_input, Data, DeriveInput, Type, Meta, DataStruct, Field};
</span><span>
</span><span>#[</span><span style="color:#bf616a;">proc_macro_derive</span><span>(Material, </span><span style="color:#bf616a;">attributes</span><span>(material, texture, color))]
</span><span style="color:#b48ead;">pub fn </span><span style="color:#8fa1b3;">derive_material</span><span>(</span><span style="color:#bf616a;">input</span><span>: TokenStream) -&gt; TokenStream {
</span><span>    </span><span style="color:#b48ead;">let</span><span> input = parse_macro_input!(input as DeriveInput);
</span><span>    ...
</span><span>}
</span></code></pre>
<p>Також додамо структуру <code>Opts</code>, де будуть зберігатися атрибути самого матеріалу:</p>
<pre data-lang="rust" style="background-color:#2b303b;color:#c0c5ce;" class="language-rust "><code class="language-rust" data-lang="rust"><span>#[</span><span style="color:#bf616a;">derive</span><span>(FromDeriveInput)]
</span><span>#[</span><span style="color:#bf616a;">darling</span><span>(</span><span style="color:#bf616a;">attributes</span><span>(material))]
</span><span style="color:#b48ead;">struct </span><span>Opts {
</span><span>    </span><span style="color:#bf616a;">vertex</span><span>: Option&lt;String&gt;,
</span><span>    </span><span style="color:#bf616a;">fragment</span><span>: Option&lt;String&gt;,
</span><span>    </span><span style="color:#bf616a;">topology</span><span>: Option&lt;String&gt;,
</span><span>}
</span></code></pre>
<p>Отримаємо атрибути матеріалу за допомогою <code>Opts::from_derive_input</code>; збережемо його ідентифіактор у змінній <code>ident</code> й дані самої структури у змінній <code>data</code>, паралельно обмежуючи використання макроса на типах крім <code>struct</code> конструкцією <code>let ... else</code>:</p>
<pre data-lang="rust" style="background-color:#2b303b;color:#c0c5ce;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#b48ead;">let</span><span> opts = Opts::from_derive_input(&amp;input).</span><span style="color:#96b5b4;">expect</span><span>(&quot;</span><span style="color:#a3be8c;">Wrong options</span><span>&quot;);
</span><span style="color:#b48ead;">let</span><span> ident = input.ident;
</span><span>
</span><span style="color:#b48ead;">let </span><span>Data::Struct(data) = input.data </span><span style="color:#b48ead;">else </span><span>{
</span><span>    panic!(&quot;</span><span style="color:#a3be8c;">Cannot make non-struct type into Material!</span><span>&quot;)
</span><span>};
</span></code></pre>
<p>Початковий output нашого макросу (без генерації білдера) виглядатиме так:</p>
<pre data-lang="rust" style="background-color:#2b303b;color:#c0c5ce;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#b48ead;">let</span><span> output = quote! {
</span><span>    #[::</span><span style="color:#bf616a;">flatbox</span><span>::</span><span style="color:#bf616a;">assets</span><span>::</span><span style="color:#bf616a;">typetag</span><span>::</span><span style="color:#bf616a;">serde</span><span>]
</span><span>    </span><span style="color:#b48ead;">impl </span><span>::flatbox::render::Material </span><span style="color:#b48ead;">for</span><span> #ident {
</span><span>        #vertex
</span><span>        #fragment
</span><span>        #input
</span><span>    }
</span><span>}
</span></code></pre>
<p>Отже, для цього створимо три змінні: vertex, fragment та input, а також відповідні функції, що будуть повертати <code>TokenStream</code>:</p>
<pre data-lang="rust" style="background-color:#2b303b;color:#c0c5ce;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#b48ead;">let</span><span> vertex = </span><span style="color:#96b5b4;">get_vertex_path</span><span>(&amp;opts);
</span><span style="color:#b48ead;">let</span><span> fragment = </span><span style="color:#96b5b4;">get_fragment_path</span><span>(&amp;opts);
</span><span style="color:#b48ead;">let</span><span> input = </span><span style="color:#96b5b4;">get_shader_input</span><span>(&amp;opts, &amp;data);
</span><span>
</span><span>...
</span><span>
</span><span style="color:#b48ead;">fn </span><span style="color:#8fa1b3;">get_vertex_path</span><span>(</span><span style="color:#bf616a;">opts</span><span>: &amp;Opts) -&gt; proc_macro2::TokenStream {...}
</span><span style="color:#b48ead;">fn </span><span style="color:#8fa1b3;">get_fragment_path</span><span>(</span><span style="color:#bf616a;">opts</span><span>: &amp;Opts) -&gt; proc_macro2::TokenStream {...}
</span><span style="color:#b48ead;">fn </span><span style="color:#8fa1b3;">get_shader_input</span><span>(</span><span style="color:#bf616a;">opts</span><span>: &amp;Opts, </span><span style="color:#bf616a;">data</span><span>: &amp;DataStruct) -&gt; proc_macro2::TokenStream {...}
</span></code></pre>
<p>За допомогою <code>match</code> отримуємо шлях до шейдера з атрибутів vertex та fragment, і використовуємо його в іншому процедурному макросі <code>include_glsl!</code> з крейту <a href="https://crates.io/crates/vk-shader-macros"><code>vk-shader-macros</code></a>:</p>
<pre data-lang="rust" style="background-color:#2b303b;color:#c0c5ce;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#b48ead;">fn </span><span style="color:#8fa1b3;">get_vertex_path</span><span>(</span><span style="color:#bf616a;">opts</span><span>: &amp;Opts) -&gt; proc_macro2::TokenStream {
</span><span>    </span><span style="color:#b48ead;">match </span><span>&amp;opts.vertex {
</span><span>        Some(path) =&gt; quote! {
</span><span>            </span><span style="color:#b48ead;">fn </span><span style="color:#8fa1b3;">vertex</span><span>() -&gt; &amp;</span><span style="color:#b48ead;">&#39;static </span><span>[</span><span style="color:#b48ead;">u32</span><span>] {
</span><span>                ::flatbox::render::include_glsl!(
</span><span>                    #path, 
</span><span>                    kind: vert,
</span><span>                )
</span><span>            }
</span><span>        },
</span><span>        None =&gt; panic!(&quot;</span><span style="color:#a3be8c;">Use proc macro attribute #[material(vertex = </span><span style="color:#96b5b4;">\&quot;</span><span style="color:#a3be8c;">path</span><span style="color:#96b5b4;">\&quot;</span><span style="color:#a3be8c;">)] to set vertex shader path</span><span>&quot;),
</span><span>    }
</span><span>}
</span><span>
</span><span style="color:#b48ead;">fn </span><span style="color:#8fa1b3;">get_fragment_path</span><span>(</span><span style="color:#bf616a;">opts</span><span>: &amp;Opts) -&gt; proc_macro2::TokenStream {
</span><span>    </span><span style="color:#b48ead;">match </span><span>&amp;opts.fragment {
</span><span>        Some(path) =&gt; quote! {
</span><span>            </span><span style="color:#b48ead;">fn </span><span style="color:#8fa1b3;">fragment</span><span>() -&gt; &amp;</span><span style="color:#b48ead;">&#39;static </span><span>[</span><span style="color:#b48ead;">u32</span><span>] {
</span><span>                ::flatbox::render::include_glsl!(
</span><span>                    #path, 
</span><span>                    kind: frag,
</span><span>                )
</span><span>            }
</span><span>        },
</span><span>        None =&gt; panic!(&quot;</span><span style="color:#a3be8c;">Use proc macro attribute #[material(fragment = </span><span style="color:#96b5b4;">\&quot;</span><span style="color:#a3be8c;">path</span><span style="color:#96b5b4;">\&quot;</span><span style="color:#a3be8c;">)] to set fragment shader path</span><span>&quot;),
</span><span>    }
</span><span>}
</span></code></pre>
<p>Для генерації атрибутів вхідних шейдерних даних алгоритм буде трохи складнішим. Для початку нам потрібно отримати топологію примітивів та перелік форматів (типів) полів структури, які будуть використані шейдером.</p>
<pre data-lang="rust" style="background-color:#2b303b;color:#c0c5ce;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#b48ead;">fn </span><span style="color:#8fa1b3;">get_shader_input</span><span>(
</span><span>    </span><span style="color:#bf616a;">opts</span><span>: &amp;Opts,
</span><span>    </span><span style="color:#bf616a;">data</span><span>: &amp;DataStruct,
</span><span>) -&gt; proc_macro2::TokenStream {
</span><span>    </span><span style="color:#b48ead;">let</span><span> topology = ...;
</span><span>    </span><span style="color:#b48ead;">let</span><span> format = ...;
</span><span>
</span><span>    quote! {
</span><span>        </span><span style="color:#b48ead;">fn </span><span style="color:#8fa1b3;">input</span><span>() -&gt; ::flatbox::render::ShaderInput {
</span><span>            ...
</span><span>        }
</span><span>    }
</span><span>}
</span></code></pre>
<p>Одержуємо топологію способом аналогічним тому, як ми отримували шлях до шейдерів зі структури <code>Opts</code>:</p>
<pre data-lang="rust" style="background-color:#2b303b;color:#c0c5ce;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#b48ead;">let</span><span> topology = </span><span style="color:#b48ead;">match </span><span>&amp;opts.topology {
</span><span>    Some(topology) =&gt; </span><span style="color:#b48ead;">match</span><span> topology.</span><span style="color:#96b5b4;">as_str</span><span>() { </span><span style="color:#65737e;">// робимо перелік усіх можливих топологій Vulkan
</span><span>        &quot;</span><span style="color:#a3be8c;">point_list</span><span>&quot; =&gt; quote! { ::flatbox::render::ShaderTopology::</span><span style="color:#d08770;">POINT_LIST </span><span>},
</span><span>        &quot;</span><span style="color:#a3be8c;">line_list</span><span>&quot; =&gt; quote! { ::flatbox::render::ShaderTopology::</span><span style="color:#d08770;">LINE_LIST </span><span>},
</span><span>        &quot;</span><span style="color:#a3be8c;">line_strip</span><span>&quot; =&gt; quote! { ::flatbox::render::ShaderTopology::</span><span style="color:#d08770;">LINE_STRIP </span><span>},
</span><span>        &quot;</span><span style="color:#a3be8c;">triangle_list</span><span>&quot; =&gt; quote! { ::flatbox::render::ShaderTopology::</span><span style="color:#d08770;">TRIANGLE_LIST </span><span>},
</span><span>        &quot;</span><span style="color:#a3be8c;">triangle_strip</span><span>&quot; =&gt; quote! { ::flatbox::render::ShaderTopology::</span><span style="color:#d08770;">TRIANGLE_STRIP </span><span>},
</span><span>        &quot;</span><span style="color:#a3be8c;">triangle_fan</span><span>&quot; =&gt; quote! { ::flatbox::render::ShaderTopology::</span><span style="color:#d08770;">TRIANGLE_FAN </span><span>},
</span><span>        &quot;</span><span style="color:#a3be8c;">line_list_with_adjacency</span><span>&quot; =&gt; quote! { ::flatbox::render::ShaderTopology::</span><span style="color:#d08770;">LINE_LIST_WITH_ADJACENCY </span><span>},
</span><span>        &quot;</span><span style="color:#a3be8c;">line_strip_with_adjacency</span><span>&quot; =&gt; quote! { ::flatbox::render::ShaderTopology::</span><span style="color:#d08770;">LINE_STRIP_WITH_ADJACENCY </span><span>},
</span><span>        &quot;</span><span style="color:#a3be8c;">triangle_list_with_adjacency</span><span>&quot; =&gt; quote! { ::flatbox::render::ShaderTopology::</span><span style="color:#d08770;">TRIANGLE_LIST_WITH_ADJACENCY </span><span>},
</span><span>        &quot;</span><span style="color:#a3be8c;">triangle_strip_with_adjacency</span><span>&quot; =&gt; quote! { ::flatbox::render::ShaderTopology::</span><span style="color:#d08770;">TRIANGLE_STRIP_WITH_ADJACENCY </span><span>},
</span><span>        _ =&gt; panic!(&quot;</span><span style="color:#a3be8c;">Unsupported topology </span><span style="color:#96b5b4;">\&quot;</span><span style="color:#a3be8c;">{}</span><span style="color:#96b5b4;">\&quot;</span><span>&quot;, topology),
</span><span>    },
</span><span>    None =&gt; quote! { ::flatbox::render::ShaderTopology::</span><span style="color:#d08770;">TRIANGLE_LIST </span><span>}, </span><span style="color:#65737e;">// якщо атрибут відсутній, то використовувати список трикутників (рендерінг поверхні граней 3Д-моделей) за замовчуванням
</span><span>};
</span></code></pre>
<p>Щоб отримати перелік форматів полів, проітеруємо структуру <code>data.fields</code> та повернемо <code>Map&lt;...&gt;</code>:</p>
<pre data-lang="rust" style="background-color:#2b303b;color:#c0c5ce;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#b48ead;">let</span><span> format = data.fields.</span><span style="color:#96b5b4;">iter</span><span>().</span><span style="color:#96b5b4;">map</span><span>(|</span><span style="color:#bf616a;">f</span><span>| {
</span><span>    </span><span style="color:#b48ead;">let</span><span> ty = &amp;f.ty;
</span><span>    </span><span style="color:#b48ead;">match</span><span> ty {
</span><span>        ...
</span><span>    }
</span><span>});
</span></code></pre>
<p>Список типів, які можуть бути використані як шейдерні вхідна дані, невеликий: цілі числа, числа з рухомою комою та вектори - масиви типу [f32; 2], [f32; 3] та [f32; 4], отже кілька типів масиву та простих типів. Перевіримо тип поля <code>ty</code> на те, чи є він масивом або звичайним типом, та конвертуємо його у рядкову репрезентацію для подальшого матчінгу:</p>
<pre data-lang="rust" style="background-color:#2b303b;color:#c0c5ce;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#b48ead;">match</span><span> ty {
</span><span>    Type::Array(array) =&gt; { </span><span style="color:#65737e;">// чи масив
</span><span>        </span><span style="color:#b48ead;">match</span><span> array.</span><span style="color:#96b5b4;">into_token_stream</span><span>().</span><span style="color:#96b5b4;">to_string</span><span>().</span><span style="color:#96b5b4;">as_str</span><span>() { </span><span style="color:#65737e;">// конвертуємо тип у строку
</span><span>            &quot;</span><span style="color:#a3be8c;">[f32 ; 2]</span><span>&quot; =&gt; quote! { ::flatbox::render::ShaderInputFormat::</span><span style="color:#d08770;">R32G32_SFLOAT </span><span>},
</span><span>            &quot;</span><span style="color:#a3be8c;">[f32 ; 3]</span><span>&quot; =&gt; quote! { ::flatbox::render::ShaderInputFormat::</span><span style="color:#d08770;">R32G32B32_SFLOAT </span><span>},
</span><span>            &quot;</span><span style="color:#a3be8c;">[f32 ; 4]</span><span>&quot; =&gt; quote! { ::flatbox::render::ShaderInputFormat::</span><span style="color:#d08770;">R32G32B32A32_SFLOAT </span><span>},
</span><span>            &quot;</span><span style="color:#a3be8c;">[f32 ; 1]</span><span>&quot; =&gt; quote! { ::flatbox::render::ShaderInputFormat::</span><span style="color:#d08770;">R32_SFLOAT </span><span>}, </span><span style="color:#65737e;">// масив з одного елемента представляємо як звичайний `float`
</span><span>            _ =&gt; panic!(&quot;</span><span style="color:#a3be8c;">Unsupported input format: </span><span style="color:#96b5b4;">\&quot;</span><span style="color:#a3be8c;">{}</span><span style="color:#96b5b4;">\&quot;</span><span>&quot;, array.</span><span style="color:#96b5b4;">into_token_stream</span><span>().</span><span style="color:#96b5b4;">to_string</span><span>().</span><span style="color:#96b5b4;">as_str</span><span>())
</span><span>        }
</span><span>    },
</span><span>    Type::Path(path) =&gt; { </span><span style="color:#65737e;">// чи звичайний тип
</span><span>        </span><span style="color:#b48ead;">match</span><span> path.</span><span style="color:#96b5b4;">into_token_stream</span><span>().</span><span style="color:#96b5b4;">to_string</span><span>().</span><span style="color:#96b5b4;">as_str</span><span>() {
</span><span>            &quot;</span><span style="color:#a3be8c;">f32</span><span>&quot; =&gt; quote! { ::flatbox::render::ShaderInputFormat::</span><span style="color:#d08770;">R32_SFLOAT </span><span>},
</span><span>            &quot;</span><span style="color:#a3be8c;">u32</span><span>&quot; =&gt; quote! { ::flatbox::render::ShaderInputFormat::</span><span style="color:#d08770;">R8G8B8A8_UINT </span><span>},
</span><span>            &quot;</span><span style="color:#a3be8c;">i32</span><span>&quot; =&gt; quote! { ::flatbox::render::ShaderInputFormat::</span><span style="color:#d08770;">R8G8B8A8_SINT </span><span>},
</span><span>            _ =&gt; panic!(&quot;</span><span style="color:#a3be8c;">Unsupported input format: </span><span style="color:#96b5b4;">\&quot;</span><span style="color:#a3be8c;">{}</span><span style="color:#96b5b4;">\&quot;</span><span>&quot;, path.</span><span style="color:#96b5b4;">into_token_stream</span><span>().</span><span style="color:#96b5b4;">to_string</span><span>().</span><span style="color:#96b5b4;">as_str</span><span>())
</span><span>        }
</span><span>    },
</span><span>    _ =&gt; panic!(&quot;</span><span style="color:#a3be8c;">Unsupported input format</span><span>&quot;), </span><span style="color:#65737e;">// якщо формат поля інший - панікуємо!
</span><span>}
</span></code></pre>
<p>Тепер розглянемо структуру <code>ShaderInput</code>:</p>
<pre data-lang="rust" style="background-color:#2b303b;color:#c0c5ce;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#b48ead;">pub struct </span><span>ShaderInput {
</span><span>    </span><span style="color:#b48ead;">pub </span><span style="color:#bf616a;">attributes</span><span>: Vec&lt;ShaderInputAttribute&gt;,
</span><span>    </span><span style="color:#b48ead;">pub </span><span style="color:#bf616a;">instance_size</span><span>: </span><span style="color:#b48ead;">usize</span><span>,
</span><span>    </span><span style="color:#b48ead;">pub </span><span style="color:#bf616a;">topology</span><span>: ShaderTopology,
</span><span>}
</span></code></pre>
<p>А також внутрішню структуру <code>ShaderInputAttribute</code>:</p>
<pre data-lang="rust" style="background-color:#2b303b;color:#c0c5ce;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#b48ead;">pub struct </span><span>ShaderInputAttribute {
</span><span>    </span><span style="color:#b48ead;">pub </span><span style="color:#bf616a;">location</span><span>: </span><span style="color:#b48ead;">u32</span><span>,
</span><span>    </span><span style="color:#b48ead;">pub </span><span style="color:#bf616a;">binding</span><span>: </span><span style="color:#b48ead;">u32</span><span>,
</span><span>    </span><span style="color:#b48ead;">pub </span><span style="color:#bf616a;">format</span><span>: Format,
</span><span>    </span><span style="color:#b48ead;">pub </span><span style="color:#bf616a;">offset</span><span>: </span><span style="color:#b48ead;">u32</span><span>,
</span><span>}
</span></code></pre>
<p>Якщо топологія та формат полів у нас є, <code>binding</code> є завжди сталим, то нам все ще потрібен зсув вхідних даних (offset), їх положення (location) та сумарний розмір даних матеріалу (instance_size). Ці всі значення ми можемо отримати вже при ітерації форматів полів:</p>
<pre data-lang="rust" style="background-color:#2b303b;color:#c0c5ce;" class="language-rust "><code class="language-rust" data-lang="rust"><span>quote! {
</span><span>    </span><span style="color:#b48ead;">fn </span><span style="color:#8fa1b3;">input</span><span>() -&gt; ::flatbox::render::ShaderInput {
</span><span>        </span><span style="color:#b48ead;">let mut</span><span> location = </span><span style="color:#d08770;">3</span><span>; </span><span style="color:#65737e;">// положення першого параметра в шейдері починаючи з &quot;0&quot; (перші 3 зайняті параметрами самої 3Д-моделі)
</span><span>        </span><span style="color:#b48ead;">let mut</span><span> offset = </span><span style="color:#d08770;">0</span><span>; </span><span style="color:#65737e;">// зсув першого параметра (оскільки параметр перший, отже зсув відсутній)
</span><span>        </span><span style="color:#b48ead;">let mut</span><span> attributes = vec![];
</span><span>        #(
</span><span>            attributes.</span><span style="color:#96b5b4;">push</span><span>(
</span><span>                ::flatbox::render::ShaderInputAttribute{
</span><span>                    binding: </span><span style="color:#d08770;">1</span><span>,
</span><span>                    location: location,
</span><span>                    offset: offset,
</span><span>                    format: #format,
</span><span>                }
</span><span>            );
</span><span>
</span><span>            offset += </span><span style="color:#b48ead;">match </span><span>#format { </span><span style="color:#65737e;">// збільшуємо зсув наступного параметра на розмір поточного
</span><span>                ::flatbox::render::ShaderInputFormat::</span><span style="color:#d08770;">R8G8B8A8_UINT
</span><span>                    | ::flatbox::render::ShaderInputFormat::</span><span style="color:#d08770;">R8G8B8A8_SINT 
</span><span>                    | ::flatbox::render::ShaderInputFormat::</span><span style="color:#d08770;">R32_SFLOAT </span><span>=&gt; </span><span style="color:#d08770;">4</span><span>,
</span><span>                ::flatbox::render::ShaderInputFormat::</span><span style="color:#d08770;">R32G32_SFLOAT </span><span>=&gt; </span><span style="color:#d08770;">8</span><span>,
</span><span>                ::flatbox::render::ShaderInputFormat::</span><span style="color:#d08770;">R32G32B32_SFLOAT </span><span>=&gt; </span><span style="color:#d08770;">12</span><span>,
</span><span>                ::flatbox::render::ShaderInputFormat::</span><span style="color:#d08770;">R32G32B32A32_SFLOAT </span><span>=&gt; </span><span style="color:#d08770;">16</span><span>,
</span><span>                _ =&gt; </span><span style="color:#d08770;">0</span><span>,
</span><span>            };
</span><span>
</span><span>            location += </span><span style="color:#d08770;">1</span><span>; </span><span style="color:#65737e;">// збільшуємо положення наступного параметра на 1
</span><span>        )*
</span><span>        </span><span style="color:#b48ead;">let</span><span> instance_size = offset as </span><span style="color:#b48ead;">usize</span><span>; </span><span style="color:#65737e;">// по завершенню ітерацій встановлюємо загальний розмір даних 
</span><span>
</span><span>        ::flatbox::render::ShaderInput {
</span><span>            attributes,
</span><span>            instance_size,
</span><span>            topology: #topology,
</span><span>        }
</span><span>    }
</span><span>}
</span></code></pre>
<p>Отже, тепер реалізація трейту <code>Material</code> для власного типу буде виконуватися набагато простіше. Але не забуваємо про генерацію білдеру, що може ще більше полегшити створення кастомних матеріалів.</p>
<h2 id="generatsiia-mymaterialbuilder">Генерація MyMaterialBuilder</h2>
<p>Розширимо output макросу і додамо реалізацію створення білдеру:</p>
<pre data-lang="rust" style="background-color:#2b303b;color:#c0c5ce;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#b48ead;">let</span><span> output = quote! {
</span><span>    #[::</span><span style="color:#bf616a;">flatbox</span><span>::</span><span style="color:#bf616a;">assets</span><span>::</span><span style="color:#bf616a;">typetag</span><span>::</span><span style="color:#bf616a;">serde</span><span>]
</span><span>    </span><span style="color:#b48ead;">impl </span><span>::flatbox::render::Material </span><span style="color:#b48ead;">for</span><span> #ident {
</span><span>        #vertex
</span><span>        #fragment
</span><span>        #input
</span><span>    }
</span><span>
</span><span>    </span><span style="color:#b48ead;">impl </span><span>#ident {
</span><span>        </span><span style="color:#b48ead;">pub fn </span><span style="color:#8fa1b3;">builder</span><span>() -&gt; #ident_builder { </span><span style="color:#65737e;">// додаємо функцію ініціалізації білдера в матеріал
</span><span>            #ident_builder::new()
</span><span>        }
</span><span>    }
</span><span>
</span><span>    #[</span><span style="color:#bf616a;">derive</span><span>(Clone, Default, Debug)]
</span><span>    </span><span style="color:#b48ead;">pub struct </span><span>#ident_builder { </span><span style="color:#65737e;">// генеруємо саму структуру білдера
</span><span>        #(#fields,)*
</span><span>    }
</span><span>
</span><span>    </span><span style="color:#b48ead;">impl </span><span>#ident_builder {
</span><span>        </span><span style="color:#b48ead;">pub fn </span><span style="color:#8fa1b3;">new</span><span>() -&gt; </span><span style="color:#b48ead;">Self </span><span>{ </span><span style="color:#65737e;">// ...шаблонна функція ініціалізації
</span><span>            </span><span style="color:#b48ead;">Self</span><span>::default()
</span><span>        }
</span><span>
</span><span>        </span><span style="color:#b48ead;">pub fn </span><span style="color:#8fa1b3;">build</span><span>(</span><span style="color:#bf616a;">self</span><span>) -&gt; #ident { </span><span style="color:#65737e;">// ...метод, що створює екземпляр матеріалу з даних білдера
</span><span>            #ident {
</span><span>                #(#build_function)*
</span><span>            }
</span><span>        }
</span><span>
</span><span>        #(#functions)* </span><span style="color:#65737e;">// і додаємо функції налаштування білдера
</span><span>    }
</span><span>};
</span></code></pre>
<p>Тепер йдемо по порядку. Треба створити ідентифікатор білдера. Це робиться просто: всього лиш додаємо суфікс &quot;Builder&quot; до ідентифікатора структури. Зробимо це за допомогою макроса <code>format!</code>:</p>
<pre data-lang="rust" style="background-color:#2b303b;color:#c0c5ce;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#b48ead;">let</span><span> ident_builder = Ident::new(format!(&quot;</span><span style="color:#d08770;">{}</span><span style="color:#a3be8c;">Builder</span><span>&quot;, ident.</span><span style="color:#96b5b4;">to_string</span><span>()).</span><span style="color:#96b5b4;">as_str</span><span>(), Span::call_site());
</span></code></pre>
<p>Далі треба скопіювати поля структури до білдера, щоб потім використовувати їх при його ініціалізації:</p>
<pre data-lang="rust" style="background-color:#2b303b;color:#c0c5ce;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#b48ead;">let</span><span> fields = data.fields.</span><span style="color:#96b5b4;">iter</span><span>().</span><span style="color:#96b5b4;">map</span><span>(|</span><span style="color:#bf616a;">f</span><span>| {
</span><span>    </span><span style="color:#b48ead;">let</span><span> name = &amp;f.ident;
</span><span>    </span><span style="color:#b48ead;">let</span><span> ty = &amp;f.ty;
</span><span>
</span><span>    quote! {
</span><span>        #name: #ty
</span><span>    }
</span><span>});
</span></code></pre>
<p>Створимо функції за назвами полів структури (<code>color()</code>, <code>albedo()</code> тощо) для конфігурації білдера:</p>
<pre data-lang="rust" style="background-color:#2b303b;color:#c0c5ce;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#b48ead;">let</span><span> functions = data.fields.</span><span style="color:#96b5b4;">iter</span><span>().</span><span style="color:#96b5b4;">map</span><span>(|</span><span style="color:#bf616a;">f</span><span>| {
</span><span>    </span><span style="color:#b48ead;">let</span><span> name = &amp;f.ident;
</span><span>    </span><span style="color:#b48ead;">let</span><span> ty = &amp;f.ty;
</span><span>    </span><span style="color:#b48ead;">let</span><span> attr = </span><span style="color:#b48ead;">match</span><span> f.attrs.</span><span style="color:#96b5b4;">get</span><span>(</span><span style="color:#d08770;">0</span><span>) {
</span><span>        Some(attr) =&gt; {
</span><span>            ...
</span><span>        },
</span><span>        None =&gt; FieldAttribute::None,
</span><span>    };
</span><span>
</span><span>    ...
</span><span>});
</span></code></pre>
<p>Давайте для зручності створимо перелік <code>FieldAttribute</code>, що визначатиме, який атрибут був застосований до даного поля (і чи був взагалі):</p>
<pre data-lang="rust" style="background-color:#2b303b;color:#c0c5ce;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#b48ead;">enum </span><span>FieldAttribute {
</span><span>    Texture,
</span><span>    Color,
</span><span>    None,
</span><span>}
</span></code></pre>
<p>Тоді маємо:</p>
<pre data-lang="rust" style="background-color:#2b303b;color:#c0c5ce;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#b48ead;">let</span><span> attr = </span><span style="color:#b48ead;">match</span><span> f.attrs.</span><span style="color:#96b5b4;">get</span><span>(</span><span style="color:#d08770;">0</span><span>) {
</span><span>    Some(attr) =&gt; {
</span><span>        </span><span style="color:#b48ead;">if let </span><span>Meta::Path(path) = &amp;attr.meta {
</span><span>            </span><span style="color:#b48ead;">match</span><span> path.</span><span style="color:#96b5b4;">into_token_stream</span><span>().</span><span style="color:#96b5b4;">to_string</span><span>().</span><span style="color:#96b5b4;">as_str</span><span>() { </span><span style="color:#65737e;">// знову репрезентуємо токени як рядок тексту
</span><span>                &quot;</span><span style="color:#a3be8c;">color</span><span>&quot; =&gt; FieldAttribute::Color,
</span><span>                &quot;</span><span style="color:#a3be8c;">texture</span><span>&quot; =&gt; FieldAttribute::Texture,
</span><span>                _ =&gt; panic!(&quot;</span><span style="color:#a3be8c;">Invalid field attribute: </span><span style="color:#96b5b4;">\&quot;</span><span style="color:#a3be8c;">{}</span><span style="color:#96b5b4;">\&quot;</span><span>&quot;, attr.</span><span style="color:#96b5b4;">into_token_stream</span><span>().</span><span style="color:#96b5b4;">to_string</span><span>().</span><span style="color:#96b5b4;">as_str</span><span>()),
</span><span>            }
</span><span>        } </span><span style="color:#b48ead;">else </span><span>{
</span><span>            panic!(&quot;</span><span style="color:#a3be8c;">Invalid field attribute: </span><span style="color:#96b5b4;">\&quot;</span><span style="color:#a3be8c;">{}</span><span style="color:#96b5b4;">\&quot;</span><span>&quot;, attr.</span><span style="color:#96b5b4;">into_token_stream</span><span>().</span><span style="color:#96b5b4;">to_string</span><span>().</span><span style="color:#96b5b4;">as_str</span><span>());
</span><span>        }
</span><span>    },
</span><span>    None =&gt; FieldAttribute::None,
</span><span>    
</span><span>    ...
</span><span>};
</span></code></pre>
<p>А тепер перевіряємо атрибути для коректної генерації нашої функції:</p>
<pre data-lang="rust" style="background-color:#2b303b;color:#c0c5ce;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#b48ead;">match</span><span> attr {
</span><span>    FieldAttribute::Color =&gt; quote! {
</span><span>        </span><span style="color:#b48ead;">pub fn </span><span>#</span><span style="color:#96b5b4;">name</span><span>(</span><span style="color:#b48ead;">mut </span><span style="color:#bf616a;">self</span><span>, value: ::flatbox::render::Color&lt;</span><span style="color:#b48ead;">f32</span><span>&gt;) -&gt; </span><span style="color:#b48ead;">Self </span><span>{ 
</span><span>            </span><span style="color:#bf616a;">self</span><span>.#name = value.</span><span style="color:#96b5b4;">into</span><span>();
</span><span>            </span><span style="color:#bf616a;">self
</span><span>        }
</span><span>    },
</span><span>    FieldAttribute::Texture =&gt; quote! {
</span><span>        </span><span style="color:#b48ead;">pub fn </span><span>#</span><span style="color:#96b5b4;">name</span><span>(</span><span style="color:#b48ead;">mut </span><span style="color:#bf616a;">self</span><span>, value: ::flatbox::assets::AssetHandle&lt;&#39;T&#39;&gt;) -&gt; </span><span style="color:#b48ead;">Self </span><span>{ 
</span><span>            </span><span style="color:#bf616a;">self</span><span>.#name = value.</span><span style="color:#96b5b4;">into</span><span>();
</span><span>            </span><span style="color:#bf616a;">self
</span><span>        }
</span><span>    },
</span><span>    _ =&gt; quote! {
</span><span>        </span><span style="color:#b48ead;">pub fn </span><span>#</span><span style="color:#96b5b4;">name</span><span>(</span><span style="color:#b48ead;">mut </span><span style="color:#bf616a;">self</span><span>, value: #ty) -&gt; </span><span style="color:#b48ead;">Self </span><span>{ 
</span><span>            </span><span style="color:#bf616a;">self</span><span>.#name = value;
</span><span>            </span><span style="color:#bf616a;">self
</span><span>        }
</span><span>    },
</span><span>}
</span></code></pre>
<p>І нарешті для функції <code>build()</code> згенеруємо &quot;присвоєння&quot; полям нового матеріалу значень полів білдера:</p>
<pre data-lang="rust" style="background-color:#2b303b;color:#c0c5ce;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#b48ead;">let</span><span> build_function = data.fields.</span><span style="color:#96b5b4;">iter</span><span>().</span><span style="color:#96b5b4;">map</span><span>(|</span><span style="color:#bf616a;">f</span><span>| {
</span><span>    </span><span style="color:#b48ead;">let</span><span> name = &amp;f.ident;
</span><span>    quote! {
</span><span>        #name: </span><span style="color:#bf616a;">self</span><span>.#name,
</span><span>    }
</span><span>});
</span></code></pre>
<h2 id="zakliuchennia">Заключення</h2>
<p>Таким чином, що ми маємо?</p>
<ol>
<li>Створення атрибутів полів матеріалу для їх використання у шейдерах;</li>
<li>Автоматична генерація білдеру матеріалу для його швидкої ініціалізації.</li>
</ol>
<p>Що можна ще зробити?</p>
<p>Як приклад, можна додати атрибут поля <code>#[default = ...]</code>, що буде задавати стандартні значення полів у білдері під час його створення.</p>
<p>Повний код макросу ви можете знайти <a href="https://github.com/konceptosociala/flatbox_legacy/blob/main/macros/src/lib.rs">за посиланням</a>.</p>

</div><script src="https://utteranc.es/client.js"
        repo="konceptosociala&#x2F;konceptosociala.github.io"
        issue-term="pathname"label="KS Comment"theme="photon-dark"
        crossorigin="anonymous"
        async>
</script>
    </div>
    <div class="curve-section">
        <svg data-name="Layer 1" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 1200 120" preserveAspectRatio="none">
            <path d="M1200 120L0 16.48 0 0 1200 0 1200 120z" class="shape-fill" style="fill: #393C44"></path>
        </svg>
    </div>
</section><footer class="d-flex flex-wrap justify-content-between align-items-center" style="background: #1D1E23">
        <div class="col-md-4 d-flex align-items-center">
            <a href="/" class="mb-3 me-2 mb-md-0 text-light text-decoration-none lh-1">
                <svg class="bi" width="30" height="24"><use xlink:href="#bootstrap"></use></svg>
            </a>
            <span class="text-light">Koncepto Sociala © 2023</span>
        </div>
      
        <ul class="nav p-3 col-md-4 justify-content-end list-unstyled d-flex"><li class="ms-3"><a title="GitHub" class="fa fa-github social" href="https:&#x2F;&#x2F;github.com&#x2F;konceptosociala&#x2F;"></a></li><li class="ms-3"><a title="E-mail" class="fa fa-email-bulk social" href="mailto:sanerhp.mail@gmail.com"></a></li><li class="ms-3"><a title="Telegram" class="fa fa-telegram social" href="https:&#x2F;&#x2F;t.me&#x2F;ksociala_official"></a></li></ul>
    </footer><script src="https://ajax.googleapis.com/ajax/libs/jquery/3.7.0/jquery.min.js"></script> 
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/js/bootstrap.bundle.min.js" integrity="sha384-geWF76RCwLtnZ8qwWowPQNguL3RmwHVBC9FhGdlKrxdiJJigb/j/68SIy3Te4Bkz" crossorigin="anonymous"></script>
    <script src="https://konceptosociala.eu.org/js/script.js"></script>
</body>
</html>